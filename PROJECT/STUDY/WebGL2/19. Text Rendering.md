# Span 
`<span>` 태그는  
**자체적으로 특별한 의미가 전혀 없는 인라인 컨테이너**로  
단순 텍스트나 인라인 콘텐츠 등에 **스타일이나 속성, 스크립트를 위한 범위를 위해 감싸주는 태그**입니다.

|          |                                                                                                             |
| -------- | ----------------------------------------------------------------------------------------------------------- |
| `<div>`  | 레이아웃(블록이나 구획)을 구성하거나 그룹화된 마크업이나 콘텐츠에 스타일이나 자바스크립트를 적용하기 위한 컨테이너나, HTML 속성을 적용하기 위한 범위를 나타내기 위한 컨테이너로 사용합니다. |
| `<span>` | 단순 텍스트나 텍스트에 관련된 마크업 등 구문 콘텐츠에 스타일이나 자바스크립트를 적용하기 위한 범위를 감싸주거나, HTML 속성을 적용하기 위한 범위를 감싸주기 위해 사용됩니다.         |

> [!NOTE] WARNING
> `<span>` 태그를 레이아웃(블록이나 구획)을 구성하는데 사용하지 마세요!  
`<div>` 태그가 더 적당합니다.


- **스타일을 적용하기 위한 CSS 선택자**로 사용하거나,
- **HTML 속성을 적용하기 위한 범위**를 나타내기 위해 주로 사용되거나
- **자바스크립트에서 특정 부분을 선택하거나 조작**하는 데 사용하거나,
- **오직 시각적 스타일을 위한 장식용 태그**로 사용됩니다.

# Overlay 기법

WebGL은 브라우져에서 실행됨. 적절히 브라우져의 기능을 활용해야함.
CSS, HTML에 이미 제공되는 기능을 활용


# Rendering Text Size

그려진 텍스트의 크기가 작은 경우는? Canvas 2D 기본 크기 때문

URL: [Drawing text - Web APIs | MDN (mozilla.org)](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_text)


# BLEND



```cpp
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
```

sorce pixcel(fragment shader의 색상)을 가져와 blend 함수를 이용해 dest(canvas color)와 결합한다. 

단순히 BLEND 옵션을 활성화 하는 경우 아래와 같은 현상을 볼 수 있다. **Depth Buffer**가 있기 때문에 F의 텍스트를 그릴 때 블렌딩으로 일부 픽셀이 배경색을 유지하더라도, depth Buffer는 여전히 갱신됨. (다음번 **F**를 그릴 때 텍스트 픽셀 뒤에 있다면 그려지지 않는다. 이미지 참고.)
![[Pasted image 20240805154310.png|center]]

**투명도 문제**: GPU에서 3D 렌더링을 할 때 겪는 가장 어려운 문제 중 하나 
가장 일반적인 해결책은 모든 불투명체를 먼저 그리고, depth buffer **testing**은 활성화 하고, depth buffer **updating**은 끈 상태에서, Z 거리로 정렬된 물체를 모두 그리는 것.

#### 문제 해결 

먼저 불투명한 것(F)과 투명한 것(텍스트)을 분리

```js
var textPositions = [];
```

F의 렌더링 루프에서 이 위치들을 저장

```js
// remember the position for the text
textPositions.push([fViewMatrix[12], fViewMatrix[13], fViewMatrix[14]]);
```

F를 그리기 전에 blend를 비활성화하고 depth buffer 작성을 켠다.
```js ar:1
gl.disable(gl.BLEND);
gl.depthMask(true);
```

텍스트를 그리는 경우 반대로 설정
```js ar:1
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
gl.depthMask(false);
```

저장해둔 위치를 텍스트를 그린다.

```js title:'전체 코드' hl:17,18,50,70-74
function drawScene(time){
    var now = time * 0.001;
    var deltaTime = now - then;
    then = now;

    twgl.resizeCanvasToDisplaySize(gl.canvas);

    rotation[1] += rotationSpeed * deltaTime;

    gl.viewport(0,0,gl.canvas.width, gl.canvas.height);
    gl.clearColor(0,0,0,0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);

    gl.disable(gl.BLEND);
    gl.depthMask(true);

    var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
    var zNear = 1;
    var zFar = 2000;
    var projectionMatrix = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);

    var cameraRadius = 360;
    var cameraPosition = [Math.cos(now) * cameraRadius, 0, Math.sin(now)* cameraRadius];
    var target = [0, 0, 0];
    var up = [0, 1, 0] ;
    var cameraMatrix = m4.lookAt(cameraPosition, target, up);
    var viewMatrix = m4.inverse(cameraMatrix);

    var textPositions = [];

    var spread = 170;
    for (var yy = -1; yy <= 1; ++yy) {
      for (var xx = -2; xx <= 2; ++xx) {
        var fViewMatrix = m4.translate(viewMatrix, 
          translation[0] + xx * spread,
          translation[1] + yy * spread,
          translation[2]
        );

        fViewMatrix = m4.xRotate(fViewMatrix, rotation[0]);
        fViewMatrix = m4.yRotate(fViewMatrix, rotation[1] + yy * xx * 0.2);
        fViewMatrix = m4.zRotate(fViewMatrix, rotation[2] + now + (yy * 3 + xx) * 0.1);
        fViewMatrix = m4.scale(fViewMatrix, scale[0], scale[1], scale[2]);
        fViewMatrix = m4.translate(fViewMatrix, -50, -75, 0);
        
        // remember the position for the text
        textPositions.push([fViewMatrix[12], fViewMatrix[13], fViewMatrix[14]]);

        gl.useProgram(fProgramInfo.program);

        gl.bindVertexArray(fVAO);
        fUniforms.u_matrix = m4.multiply(projectionMatrix, fViewMatrix);
        twgl.setUniforms(fProgramInfo, fUniforms);
        twgl.drawBufferInfo(gl, fBufferInfo);

        // setup to draw the text.
        gl.useProgram(textPrograminfo.program);
        
        gl.bindVertexArray(textVAO);

        m4.copy(textMatrix, textUniforms.u_matrix);
        twgl.setUniforms(textPrograminfo, textUniforms);
        twgl.drawBufferInfo(gl, textBufferInfo);
      }
    }
    
	gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthMask(false);
    
    textPositions.forEach(function(pos) {
      // use just the view position of the 'F' for the text
      // because pos is in view space that means it's a vector from the eye to
      // some position. So translate along that vector back toward the eye some distance
      var fromEye = m4.normalize(pos);
      var amountToMoveTowardEye = 150;  // because the F is 150 units long
      var viewX = pos[0] - fromEye[0] * amountToMoveTowardEye;
      var viewY = pos[1] - fromEye[1] * amountToMoveTowardEye;
      var viewZ = pos[2] - fromEye[2] * amountToMoveTowardEye;  
      var textMatrix = m4.translate(projectionMatrix, viewX, viewY, viewZ);
      // scale the F to the size we need it.
      textMatrix = m4.scale(textMatrix, textWidth, textHeight, 1);
      // setup to draw the text.
      gl.useProgram(textProgramInfo.program);
      gl.bindVertexArray(textVAO);
      m4.copy(textMatrix, textUniforms.u_matrix);
      twgl.setUniforms(textProgramInfo, textUniforms);
      // Draw the text.
      twgl.drawBufferInfo(gl, textBufferInfo);
    });
    requestAnimationFrame(drawScene);
  }
  ```
  
![[Pasted image 20240805162426.png|center]]여기서 문제는 Canvas 2D API가 미리 곱한 알파 값만 나타낸다는 겁니다. 캔버스의 컨텐츠를 텍스처에 업로드할 때 WebGL은 값을 미리 곱하지 않으려고 하지만 미리 곱한 알파는 손실되었기 때문에 이를 완벽히 수행할 수 없습니다.

이를 고치기 위해 미리 곱하지 말라고 WebGL에 지시해봅시다.
```js
gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
```



후 .. 길다 다음에 계속..