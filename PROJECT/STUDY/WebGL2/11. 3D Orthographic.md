# 직교투영(Orthographic)



![[3df.svg|center|300]]


```cpp title:"Vertex Shader" hl:11,14
#version 300 es
in vec4 a_position;
in vec4 a_color;

uniform mat4 u_matrix;

out vec4 v_color;

void main() {
	// multiply the position by the matrix
	gl_Position = u_matrix * a_position;

	// pass the color to the fragment shader
	v_color = a_color;
}
```

```cpp title:'Fragment Shader' hl:3-4
    #version 300 es
    precision highp float;
    // the varied color passed from the vertex shader
    in vec4 v_color;
    out vec4 outColor;

    void main()  {
        outColor = v_color;
    }
```

색상을 전달하기 위해서 Attribute Location을 찾고 Buffer와 Attribute를 설정
1. Location 찾기 -  `a_color`
2. Buffer 생성 - `gl.createBuffer()`
3. Binding -  `gl.bindBuffer()`
4. 데이터 설정 - `setColors(gl)`
5. Attribute 활성화 - `gl.enableVertexAttribArray(attributelocation)`

```js title:"drawScene" hl:3
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 16 * 6;
    gl.drawArrays(primitiveType, offset, count);

```

- 삼각형 **2개**로 이루어진 직사각형 **16개**의 정점 데이터 

### Culling

- **정면(front facing)**: 정점들이 **반시계 방향**으로 선언
- **뒷면(back facing)**: 정점들이 **시계 방향**으로 선언


```js title:'뒷면 삼각형들을 "culling"'
gl.enable(gl.CULL_FACE);
```

![[Pasted image 20240719163159.png|center|]]

WebGL은 삼각형이 정면인지 뒷면인지를 정점 쉐이더에서 정점을 변환한 **후에** 판별.
정면 삼각형이 어떤 이유에서건 스케일링이나 회전을 통해 뒤집히게 된다면, WebGL은 그 삼각형을 그리지 않음.

---

### Depth Buffer

==Z-Buffer==라고도 불린다. 깊이 픽셀로 이루어진 직사각형
깊이 픽셀은 우리가 **정점 쉐이더**에서 반환하는 **Z값**을 기반으로 계산됩니다. X와 Y값에 대해 클립 공간으로 변환해야 하는 것처럼, Z값도 클립 공간(또는 -1에서 +1 사이)으로 변환해야 합니다.

어떤 픽셀 뒤쪽에 있는 픽셀은 그려지지 않는다.
그리기 전 깊이 버퍼 초기화 필요

```js
gl.enable(gl.DEPTH_TEST);
```


```js
function drawScene() {
    ...
    // canvas와 깊이 버퍼를 clear
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    ...
```


---

### gl.vertexAttribPointer의 size가 3인 이유

```js
// attribute에게 positionBuffer (ARRAY_BUFFER)로부터 데이터를 가져오는 법을 알려줍니다. 
var size = 3;          // iteration마다 3 개의 component
var type = gl.FLOAT;   // 데이터는 32bit floats
var normalize = false; // 데이터를 정규화하지 않음
var stride = 0;        // 0 = 각 iteration마다 다음 위치값을 얻기 위해 size * sizeof(type) 만큼 앞으로 이동
var offset = 0;        // 버퍼의 맨 앞부분부터 시작
gl.vertexAttribPointer(
    positionAttributeLocation, size, type, normalize, stride, offset);
 
...
// attribute에게 colorBuffer (ARRAY_BUFFER)로부터 데이터를 가져오는 법을 알려줍니다. 
var size = 3;          // iteration마다 3개의 component
var type = gl.UNSIGNED_BYTE;   // 데이터는 8bit unsigned bytes
var normalize = true;  // 0-255 범위에서 0.0-1.0 범위로 변환
var stride = 0;        // 0 = 각 iteration마다 다음 색상값을 얻기 위해 size * sizeof(type) 만큼 앞으로 이동
var offset = 0;        // 버퍼의 맨 앞부분부터 시작
gl.vertexAttribPointer(
    colorAttributeLocation, size, type, normalize, stride, offset);
```

- `size = 3`은 버퍼에서 iteration마다, attribute마다 ==3개==의 값을 가져오라는 의미 
- WebGL의 정점 쉐이더는 입력하지 않는 값에 대해 기본값을 사용
	 -  **x = 0, y = 0, z = 0, w = 1**
-  2D에서는 `z` 값을 직접 넘겨줘야 했지만, 3D에서는  `w`의 기본값`1`을 이용할 수 있음