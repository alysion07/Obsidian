WebGL에서 무언가를 그릴때 마다 두개의 Shader가 필요함. V.S(Vertex Shader)와 F.S(Fragment Shader)임. 각 Shader는 함수이며,  Shader Program에 **V.S와 F.S가 함께 링크**됨

## Vertex Shader

V.S의 일은 ClipSpace 좌표를 생성하는 것.
```cs
#version 300 es
void main() {
	gl_Position = doMathToMakeClipspaceCoordinates
}
```

Shader는 정점당 한번 호출. 
호출될 때 마다 특수한 전역 변수인 `gl_Position`에 Clipspace Coordi를 할당해야함.

V.S는 데이터가 필요함. 3가지 방법으로 받을 수 있음

1. Attributes - 버퍼에서 가져온 데이터
2. Uniforms - draw call 마다 모든 정점에서 동일하게 유지되는 값
3. Textures - Pixel / Texel 데이터

### Attribute 
V.S에서 데이터를 얻는 가장 일반적인 방법은 Buffer와 Attribute를 이용하는 것.

```js
// 버퍼 생성
var buf = gl.createBuffer();

// 버퍼에 데이터를 넣음
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, someData, gl.STATIC_DRAW);

// Shader Program에서 Attributes의 Locatoin을 찾는다
var positionLoc = gl.getAttribLocation(someShaderProgram, "a_position");

// 이후 WebGL에 버퍼->데이터->Attribute로 전달하는 방법을 알려준다.

gl.enableVertexAttribArray(positionLoc);

var numComponent = 3;  //(x,y,z)
var type = gl.FLOAT;
var normalize = false; // 값 일반화 X 
var stride = 0;        // 다음 정점으로 이동할 보폭
var offset = 0;        // 버퍼의 시작 부분

gl.vertexAttribPointer(positionLoc, numComponent, type, normalize, stride, offset);
```

Attribute로 사용 가능한 타입 

- `float`, `vec2`, `vec3`, `vec4`,
- `mat2`, `mat3`, `mat4`, 
- `int`, `ivec2`, `ivec3`, `ivec4`, `uint`, 
- `uvec2`, `uvec3`, `uvec4`

- ---
### Uniforms

V.S 의 uniforms은 ==draw call== 마다 모든 정점에서 동일하게 유지되는 값


```cs hl:3 title:'offset을 V.S에 추가'
#version 300 es
in vec4 a_position;
uniform vec4 u_offset;

void main() {
gl_Position = a_position + u_offset;
}
```

```js
// u_offset의 위치 찾기
var offsetLoc = gl.getUniformLocation(someProgram, "u_offset");

gl.uniform4fv(offsetLoc, [1, 0, 0, 0]); // offset은 화면의 오른쪽 절반
```

```js title:'Uniforms으로 사용 가능한 타입별 함수'
gl.uniform1f (floatUniformLoc, v);                 // float
gl.uniform1fv(floatUniformLoc, [v]);               // float 또는 float array
gl.uniform2f (vec2UniformLoc,  v0, v1);            // vec2
gl.uniform2fv(vec2UniformLoc,  [v0, v1]);          // vec2 또는 vec2 array
gl.uniform3f (vec3UniformLoc,  v0, v1, v2);        // vec3
gl.uniform3fv(vec3UniformLoc,  [v0, v1, v2]);      // vec3 또는 vec3 array
gl.uniform4f (vec4UniformLoc,  v0, v1, v2, v4);    // vec4
gl.uniform4fv(vec4UniformLoc,  [v0, v1, v2, v4]);  // vec4 또는 vec4 array
 
gl.uniformMatrix2fv(mat2UniformLoc, false, [  4x element array ])  // mat2 또는 mat2 array
gl.uniformMatrix3fv(mat3UniformLoc, false, [  9x element array ])  // mat3 또는 mat3 array
gl.uniformMatrix4fv(mat4UniformLoc, false, [ 16x element array ])  // mat4 또는 mat4 array
 
gl.uniform1i (intUniformLoc,   v);                 // int
gl.uniform1iv(intUniformLoc, [v]);                 // int 또는 int array
gl.uniform2i (ivec2UniformLoc, v0, v1);            // ivec2
gl.uniform2iv(ivec2UniformLoc, [v0, v1]);          // ivec2 또는 ivec2 array
gl.uniform3i (ivec3UniformLoc, v0, v1, v2);        // ivec3
gl.uniform3iv(ivec3UniformLoc, [v0, v1, v2]);      // ivec3 또는 ivec3 array
gl.uniform4i (ivec4UniformLoc, v0, v1, v2, v4);    // ivec4
gl.uniform4iv(ivec4UniformLoc, [v0, v1, v2, v4]);  // ivec4 또는 ivec4 array
 
gl.uniform1u (intUniformLoc,   v);                 // uint
gl.uniform1uv(intUniformLoc, [v]);                 // uint 또는 uint array
gl.uniform2u (ivec2UniformLoc, v0, v1);            // uvec2
gl.uniform2uv(ivec2UniformLoc, [v0, v1]);          // uvec2 또는 uvec2 array
gl.uniform3u (ivec3UniformLoc, v0, v1, v2);        // uvec3
gl.uniform3uv(ivec3UniformLoc, [v0, v1, v2]);      // uvec3 또는 uvec3 array
gl.uniform4u (ivec4UniformLoc, v0, v1, v2, v4);    // uvec4
gl.uniform4uv(ivec4UniformLoc, [v0, v1, v2, v4]);  // uvec4 또는 uvec4 array
 
// sampler2D, sampler3D, samplerCube, samplerCubeShader, sampler2DShadow,
// sampler2DArray, sampler2DArrayShadow를 위해 사용
gl.uniform1i (samplerUniformLoc,   v);
```


`bool`, `bvec2`, `bvec3` `bvec4` 같은 타입도 있습니다.
이 타입들도 `gl.uniform?f?`, `gl.uniform?i?`, `gl.uniform?u?`같은 함수를 사용함.

#### Uniform Array

배열의 경우 모든 배열의 Uniform을 한꺼번에 설정할 수 있다.

```cs title:'Shader code'
...
uniform vec2 u_someVec2[3];
...
```

```js title:'JS code'
// in JavaScript at init time
var someVec2Loc = gl.getUniformLocation(someProgram, "u_someVec2");
// at render time
gl.uniform2fv(someVec2Loc, [1,2,3,4,5,6]); // set the entire array of u_someVec2

```

배열의 요소를 각각 설정하고 싶은 경우, 각 요소의 위치를 ​​**개별적으로 찾아야 한다.**

``` js title:'get individual elements'
// in JavaScript at init time
var someVec2Element0Loc = gl.getUniformLocation(someProgram, "u_someVec2[0]");
var someVec2Element1Loc = gl.getUniformLocation(someProgram, "u_someVec2[1]");
var someVec2Element2Loc = gl.getUniformLocation(someProgram, "u_someVec2[2]");
 
// at render time
gl.uniform2fv(someVec2Element0Loc, [1, 2]);  // set element 0
gl.uniform2fv(someVec2Element1Loc, [3, 4]);  // set element 1
gl.uniform2fv(someVec2Element2Loc, [5, 6]);  // set element 2
```

#### Strict Uniform

Struct도 마찬가지로 각 필드를 개별로 조회 해야함

``` cs title:'구조체 선언'
struct SomeStruct {
	bool active;
	vec2 someVec2;
};
uniform SomeStruct u_someThing;

```

```js
var soimeThingActiveLoc = gl.getUniformLocation(someProgram, "u_someThing.active");
var someThingSomeVec2Loc = gl.getUniformLocation(someProgram, "u_someThing.someVec2");

```

## Fragment Shader

F.S의 역할은 현재 Rasterize 되는 Pixel에 Color를 제공하는 역할.

```cs title:'fragment shader sample'
#version 300 es
precision highp float;
out vec4 outColor; 

void main()
{
	outColor = doMathTomakeAColor;
}
```

F.S는 픽셀당 한번씩 호출되며, 호출 될 때마다 지정한 out 변수를 어떤 색상으로 설정해야함.

F.S에서 데이터를 가져올 수 있는 방법 
1. Uniforms - 한번의 draw call에서 모든 픽셀에 동일하게 유지되는 데이터
2. Textures - Pixel/Texel에서 가져온 데이터
3. Varyings - Vertex Shader에서 데이터가 전달되고 보간된 데이터

##### Textures in Fragment Shaders

Shader에서 Texture value를 얻으러면 `sampler2D` uniform을 생성하고 GLSL 함수 `texture`를 사용하여 값을 추출한다.

```cs
precision highp float;

uniform sampler2D u_texture;

out vec outColor;

void main() {
	vec2 texcoord = vec2(0.5, 0.5); // get center value
	outColor = texture(u_texture, texcoord);
}
```

[여러가지 설정에 따라서](https://webgl2fundamentals.org/webgl/lessons/ko/webgl-3d-textures.html) texture에서 나오는 데이터는 달라집니다. 우리가 해야 하는 최소한의 작업은 texture를 생성하고 데이터를 넣는 것입니다.

```js
var tex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, tex);
var level = 0;
var internalFormat = gl.RGBA,
var width = 2;
var height = 1;
var border = 0; // MUST ALLWAYS BE ZERO
var format = gl.RGBA;
var type = gl.UNSIGNED_BYTE;
var data = new Uint8Array([255, 0, 0, 255, 0, 255, 0 255]);
gl.texImage2D(gl.TEXTURE_2D,
              level,
              internalFormat,
              width,
              height,
              border,
              format,
              type,
              data);
              
// set the filtering
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

// get Location
var someSamplerLoc = gl.getUniformLocatoin(someProgram, "u_texture");

// bind texture unit
var unit = 5;
gl.activeTexture(gl.TEXTURE0 + unit);
gl.bindTexture(gl.TEXTURE_2D, tex);

// Shader에게 texture를 바인딩한 unit 위치를 알려준다.
gl.uniform1i(someSamplerLoc, unit);
```

##### Verying

Verying은 V.S에서 F.S로 value를 보내는 방법
V.S & F.S에 일치하는 타입을 선언하여 사용할 수 있다.

```cs title:'Vertex shader' hl:7
#version 300 es
 
in vec4 a_position;
 
uniform vec4 u_offset;
 
out vec4 v_positionWithOffset;
 
void main() {
  gl_Position = a_position + u_offset;
  v_positionWithOffset = a_position + u_offset;
}
```

```cs title:'Fragment shader' hl:4
#version 300 es
precision highp float;
 
in vec4 v_positionWithOffset;
 
out vec4 outColor;
 
void main() {
  // convert from clipsapce (-1 <-> +1) to color space (0 -> 1).
  vec4 color = v_positionWithOffset * 0.5 + 0.5;
  outColor = color;
}
```


---

## GLSL 

GLSL stands for [Graphics Library Shader Language](https://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.3.pdf).
래스터화 그래픽스를 위한 계산 작업에 필요한 수학적 계산을 수행할 수 있도록 설계됨.
아래와 같은 타입을 지원함.

- `vec2`, `vec2`, `vec2` 
- `mat2`, `mat2`, `mat2` 
- `vec`

```cs 
vec4 a = vec4(1, 2, 3, 4);
vec4 a =a * 2.0;
// b = vec(2,4,6,8);
```

```cs title:'swizzle 지원'
v.yyyy == vec4(v.y, v.y, v.y, v.y) //v.yyyy로 사용가능
v.bgra == vec4(v.b, v.g, v.r, v.a)
```

```cs
vec4(v.rgb, 1) == vec4(v.r, v.g, v.b, 1)
```

GLSL은 타입에 매우 엄격함. 또한 다양한 내장 함수를 가지고 있음

```cs 
vec4 s = sin(v);
//같은 표현
vec4 s = vec4(sin(v.x), sin(v.y), sin(v.z), sin(v.w));
```

모든 GLSL 함수 목록: [OpenGL ES 3.0 레퍼런스 카드](https://www.khronos.org/files/opengles3-quick-reference-card.pdf)의 ==3 Page== 
완전한 글을 원한다면 [GLSL ES 3.00 스펙](https://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.3.pdf)


---

# 정리 

WebGL 
 - 다양한 셰이더를 생성
 - 데이터를 생성한 셰이더들에 제공
 - `gl.drawArrays`, `gl.drawElements`등을 호출해서, Vertex를 계산하고, pixel을 그림

