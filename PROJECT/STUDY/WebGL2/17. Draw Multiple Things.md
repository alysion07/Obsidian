
WebGL에서 무언가를 그리기 위한 동작

1. 초기화 시점에 uniform  value의 location 찾기
2. 버퍼 생성
3. VAO 생성 
4. bindBuffer(_target_) - `gl.bindBuffer(target)`
5. 버퍼 활성화 - `gl.enableVertexAttribArray(location)`
6. VAO Bind - `gl.bindVertexArray(vao)`
7. texture 활성화 및 Bind
8. uniform 설정 - `gl.uniform1f(location, value)`
9. gl.drawArray

```cpp title:'Vertex Attribute Array'
	void gl.enableVertexAttribArray(index);
```

`enableVertexAttribArray` 함수는 VertexShader가 렌더링 중 해당 속성에 **Acess** 할 수 있도록 **활성화**하는데 사용


### Initialize Time

- 모든 쉐이더 프로그램과 Location(쉐이더 내 데이터 전달 위치) 생성
- 버퍼를 생성하고 정점 데이터 업로드
- 그리고자 하는 각 물체마다 정점 배열(vertex array)을 생성
    - 각 attribute마다 `gl.bindBuffer`, `gl.vertexAttribPointer`, `gl.enableVertexAttribArray` 
    - 호출되는 인덱스 관련 데이터는 `gl.ELEMENT_ARRAY_BUFFER`에 바인딩
- 텍스처를 생성하고 텍스처 데이터 업로드

### Rendering Time

- 뷰 포트(viewport)를 clear 및 설정, 나머지 전역 상태 설정(깊이 테스트 여부, 컬링(culling) 수행 여부 등등)
- 그리고자 하는 물체마다,
    - 물체를 그리기 위해 사용 프로그램을 `gl.useProgram`을 사용해 호출
    - 해당 물체의 정점 배열을 바인딩
        - `gl.bindVertexArray` 호출
    - 그리고자 하는 물체의 uniform 설정
        - 각 uniform마다 `gl.uniformXXX` 호출
        - 텍스처를 텍스처 유닛(texture unit)에 할당하기 위해 `gl.activeTexture`와 `gl.bindTexture` 호출
    - `gl.drawArrays` 또는 `gl.drawElements` 호출

기본적으로 위와 같습니다. 이러한 작업을 수행하기 위해 코드를 어떻게 구성할 것인지는 여러분에게 달려있습니다.

## 간소화 하기 좋은 항목

1. **Shader Program**(and uniform, attribute Info)
2. **Vertex Array** (arrtibute 및 설정 방법 포함)
3. 주어진 Shader의 **uniforms**
4. gl.drawXXX에 전달할 갯수와 `gl.drawArrays`, `gl.drawElements`의 호출 여부

그려야 하는 물체들의 배열을 만들고 그 배열에 4가지 요소들을 함께 집어 넣어 놓는 것.

```cpp title:'setting Info'
var objectsToDraw = [
  {
    programInfo: programInfo,
    bufferInfo: sphereBufferInfo,
    vertexArray: sphereVAO,
    uniforms: sphereUniforms,
  },
  {
    programInfo: programInfo,
    bufferInfo: cubeBufferInfo,
    vertexArray: cubeVAO,
    uniforms: cubeUniforms,
  },
  {
    programInfo: programInfo,
    bufferInfo: coneBufferInfo,
    vertexArray: coneVAO,
    uniforms: coneUniforms,
  },
];
```


```js title:'Update Matrix'
var sphereXRotation =  time;
var sphereYRotation =  time;
var cubeXRotation   = -time;
var cubeYRotation   =  time;
var coneXRotation   =  time;
var coneYRotation   = -time;
 
// 각 물체에 대한 행렬 계산
sphereUniforms.u_matrix = computeMatrix(
    viewMatrix,
    projectionMatrix,
    sphereTranslation,
    sphereXRotation,
    sphereYRotation);
 
cubeUniforms.u_matrix = computeMatrix(
    viewMatrix,
    projectionMatrix,
    cubeTranslation,
    cubeXRotation,
    cubeYRotation);
 
coneUniforms.u_matrix = computeMatrix(
    viewMatrix,
    projectionMatrix,
    coneTranslation,
    coneXRotation,
    coneYRotation);
```

```js title:'draw Objects'

objectsToDraw.forEach(function(object) {
  var programInfo = object.programInfo;
 
  gl.useProgram(programInfo.program);
 
  // 필요한 attribute들 설정.
  gl.bindVertexArray(object.vertexArray);
 
  // uniforms 설정.
  twgl.setUniforms(programInfo, object.uniforms);
 
  // 그리기
  twgl.drawBufferInfo(gl, bufferInfo);
});

```

현존하는 대부분의 3D 엔진의 메인 렌더링 루프. 
**무엇을 계산할 지**와 **실제 draw**를 호출하는것은 **분리**되어 있다.

## Transparent 물체 그리기와 여러 리스트

##### 투명한 물체의 렌더링 
- First: 가장 뒤의 Object
- order:  뒤 -> **앞**

##### 불투명인 물체의 렌더링 
- First 가장 **앞**의 물체
- order: 앞-> **뒤**. 
- **DEPTH_TEST**가 GPU에서 다른 물체 뒤에 픽셀을 그리기 위해 **Fragment Shader를 실행하지 않음.**

대부분의  3D엔진에서는 2개의 리스트를 만들어 해결함. 하나는 불투명한 물체를 위한 리스트. 다른 하나는 투명한 물체를 위한 리스트. 불투명한 물체는 앞에서 뒤의 순서로 정렬 
투명한 물체는 깊이 순으로 정렬된다.

## 라이브러리 사용의 고려 

Geometry를 만들고 어떻게 렌더링 되길 원하는지 입력하면 런타임에 쉐이더를 생성해준다. (ex. Unity, Un-real, CrkTek)

`computeMatrix`를 반복문 안에 넣지 않은 것을 알아 채셨나요. 왜냐하면 렌더링과 행렬 계산은 당연히 분리되어야 하기 때문입니다. 행렬 계산은 주로 [장면 그래프(scene graph)를 통해 이루어지며, 다른 글에서 이에 대해 다룰 것입니다.](https://webgl2fundamentals.org/webgl/lessons/ko/webgl-scene-graph.html)


렌더링과 행렬 계산은 당연히 분리되어야 한다. 행렬 계산은 주로 [[18. Scene Graph]]를 통해 이루어진다.