
WebGL에서 무언가를 그리기 위한 동작

1. 초기화 시점에 uniform  value의 location 찾기
2. 버퍼 생성
3. VAO 생성 
4. bindBuffer(_target_) - `gl.bindBuffer(target)`
5. 버퍼 활성화 - `gl.enableVertexAttribArray(location)`
6. VAO Bind - `gl.bindVertexArray(vao)`
7. texture 활성화 및 Bind
8. uniform 설정 - `gl.uniform1f(location, value)`
9. gl.drawArray

```cpp title:'Vertex Attribute Array'
	void gl.enableVertexAttribArray(index);
```

`enableVertexAttribArray` 함수는 VertexShader가 렌더링 중 해당 속성에 **Acess** 할 수 있도록 **활성화**하는데 사용


### Initialize Time

- 모든 쉐이더 프로그램과 Location(쉐이더 내 데이터 전달 위치) 생성
- 버퍼를 생성하고 정점 데이터 업로드
- 그리고자 하는 각 물체마다 정점 배열(vertex array)을 생성
    - 각 attribute마다 `gl.bindBuffer`, `gl.vertexAttribPointer`, `gl.enableVertexAttribArray` 
    - 호출되는 인덱스 관련 데이터는 `gl.ELEMENT_ARRAY_BUFFER`에 바인딩
- 텍스처를 생성하고 텍스처 데이터 업로드

### Rendering Time

- 뷰 포트(viewport)를 clear 및 설정, 나머지 전역 상태 설정(깊이 테스트 여부, 컬링(culling) 수행 여부 등등)
- 그리고자 하는 물체마다,
    - 물체를 그리기 위해 사용 프로그램을 `gl.useProgram`을 사용해 호출
    - 해당 물체의 정점 배열을 바인딩
        - `gl.bindVertexArray` 호출
    - 그리고자 하는 물체의 uniform 설정
        - 각 uniform마다 `gl.uniformXXX` 호출
        - 텍스처를 텍스처 유닛(texture unit)에 할당하기 위해 `gl.activeTexture`와 `gl.bindTexture` 호출
    - `gl.drawArrays` 또는 `gl.drawElements` 호출

기본적으로 위와 같습니다. 이러한 작업을 수행하기 위해 코드를 어떻게 구성할 것인지는 여러분에게 달려있습니다.

## 간소화 하기 좋은 항목

1. **Shader Program**(and uniform, attribute Info)
2. **Vertex Array** (arrtibute 및 설정 방법 포함)
3. 주어진 Shader의 **uniforms**
4. gl.drawXXX에 전달할 갯수와 `gl.drawArrays`, `gl.drawElements`의 호출 여부

그려야 하는 물체들의 배열을 만들고 그 배열에 4가지 요소들을 함께 집어 넣어 놓는 것.

```cpp title:'setting Info'
var objectsToDraw = [
  {
    programInfo: programInfo,
    bufferInfo: sphereBufferInfo,
    vertexArray: sphereVAO,
    uniforms: sphereUniforms,
  },
  {
    programInfo: programInfo,
    bufferInfo: cubeBufferInfo,
    vertexArray: cubeVAO,
    uniforms: cubeUniforms,
  },
  {
    programInfo: programInfo,
    bufferInfo: coneBufferInfo,
    vertexArray: coneVAO,
    uniforms: coneUniforms,
  },
];
```


```js title:'Update Matrix'
var sphereXRotation =  time;
var sphereYRotation =  time;
var cubeXRotation   = -time;
var cubeYRotation   =  time;
var coneXRotation   =  time;
var coneYRotation   = -time;
 
// 각 물체에 대한 행렬 계산
sphereUniforms.u_matrix = computeMatrix(
    viewMatrix,
    projectionMatrix,
    sphereTranslation,
    sphereXRotation,
    sphereYRotation);
 
cubeUniforms.u_matrix = computeMatrix(
    viewMatrix,
    projectionMatrix,
    cubeTranslation,
    cubeXRotation,
    cubeYRotation);
 
coneUniforms.u_matrix = computeMatrix(
    viewMatrix,
    projectionMatrix,
    coneTranslation,
    coneXRotation,
    coneYRotation);
```

```js title:'draw Objects'

objectsToDraw.forEach(function(object) {
  var programInfo = object.programInfo;
 
  gl.useProgram(programInfo.program);
 
  // 필요한 attribute들 설정.
  gl.bindVertexArray(object.vertexArray);
 
  // uniforms 설정.
  twgl.setUniforms(programInfo, object.uniforms);
 
  // 그리기
  twgl.drawBufferInfo(gl, bufferInfo);
});

```

현존하는 대부분의 3D 엔진의 메인 렌더링 루프. 
**무엇을 계산할 지**와 **실제 draw**를 호출하는것은 **분리**되어 있다.

## Transparent 물체 그리기와 여러 시릍

투명한 문제를 그리ㄹ면 가장 멀리있는 물체가 먼저