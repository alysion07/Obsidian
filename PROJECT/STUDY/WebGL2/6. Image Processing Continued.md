```js
  function createAndSetupTexture(gl) {
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
 
    // 텍스처를 설정하여 어떤 크기의 이미지를 렌더링 할 수 있으므로 픽셀들로 작업을 합니다.
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
 
    return texture;
  }

 // 텍스처를 생성하고 이미지를 넣습니다.
  var originalImageTexture = createAndSetupTexture(gl);
 
  // 텍스처에 이미지를 업로드 합니다.
  var mipLevel = 0;               // 가장 큰 mip
  var internalFormat = gl.RGBA;   // 텍스처에서 원하는 포맷
  var srcFormat = gl.RGBA;        // 제공되는 데이터 포맷
  var srcType = gl.UNSIGNED_BYTE  // 제공되는 데이터 타입
  
  gl.texImage2D(gl.TEXTURE_2D,
                mipLevel,
                internalFormat,
                srcFormat,
                srcType,
                image);
```


```js 
var textures = [];
var framebuffers = [];
for(var ii = 0; ii < 2; ++ii){
  var texture = createAndSetupTexutre(gl);
  textures.push(texutre);
  
  var mipLevel = 0;
  var internalFormat = gl.RGBA;
  var border = 0;
  var scrFormat = gl.RGBA;
  var stcTYpe = gl.UNSIGNED_BYTE
  var data = null;
  gl.texImage2D(
        gl.TEXTURE_2D, mipLevel, internalFormat, image.width, 
        image.height, border, srcFormat, srcType, data);
  // 프레임 버퍼 생성
  var fbo = gl.createFramebuffer();
  framebuffers.push(fbo);
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

  // 텍스쳐 첨부
  var attatchmentPoint = gl.COLOR_ATTACHMENT0;
  gl.framebufferTexture2D(gl.FRAMEBUFFER, attchmentPoint, 
	  gl.TEXTURE_2D, texture, miplevel);
}
```

```js title:'Convention Kernel'
var kernals = {
	normal: [ 
		0, 0, 0,
		0, 1, 0,
		0, 0, 0
	],
	gaussianBlur: [ 
		0.045, 0.122, 0.045,
		0.122, 0.332, 0.122,
		0.045, 0.122, 0.045
	],
	unsharpen: [ 
		-1, -1, -1,
		-1,  9, -1,
		-1, -1, -1,
	],
	emboss: [
		-2, -1   0,
		-1,  1,  1,
		 0,  1,  2
	]
};

var effectToApply = [
	"gaussianBlur",
	"emboss",
	"gaussianBlur"
	"unsharpen"
];
```

```js
function drawEffects() {
  gl.useProgram(program);
  // 설정하기 원하는 attrib/buffer 바인드
  gl.bindVertexArray(vao);
  //원본 이미지를 유닛 0에서 시작
  gl.activeTexture(gl.TEXTURE0 + 0);
  gl.bindTexture(gl.TEXTURE_2D, originalImageTexture);
  //쉐이더에 텍스쳐 유닛 0에서 텍스쳐를 얻기위해 전달
  gl.uniform1i(imageLocation, 0);
  //텍스쳐를 그리는 동안 y축 뒤집기를 하지 않게 합니다.
  gl.uniform1f(flipYLocation, 1);
  //적용하려는 각 효과를 반복한다.
  var count = 0;
  for(var ii = 0, ii < tbody.rows.length; ++ii) {
    var checkbox=tbody.rows[ii].firstChild.firstChild;
    if(checkbox.checked) {
      setFrameBuffer(framebuffers[count % 2], image.width, image.height);
	
      drawWithKernel(checkbox.value);
	  // 다음 드로잉을 윟 ㅐ방금 렌덜이한 텍스쳐를 사용합니다.
	  gl.bindTexture(gl.TEXTURE_2D, textures[count % 2]);
	  // 다음 순서에 다른 텍스쳐를 사용할 수 있도록 카운트 증가
	  ++count;	  
    }
  }//end of for
  //마지막으로 캔버스에 결과를 그린다.
  gl.uniform1f(flipYLocation, -1); // 캔버스를 뒤집을 필요가 있음.
  
  setFramebuffer(null, gl.canvas.width, gl.canvas.height);
  
  drawWithKernel("normal");
}

function setFramebuffer(fbo, width, height) {
  //렌더링할 프레임버퍼를 만든다.
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
  // 쉐이더에 프레임버퍼의 해상도를 전달한다.
  gl.uniform2f(resolutionLocation, width, height);
  // WebGL에 클립공간에서 픽셀로 변환하는 방법 전달
  gl.viewport(0, 0, width, height);
}

function drawWithKernel(name) {
  //커널을 설정하고 가중치를 설정함
  gl.uniform1fv(kernelLocation, kernels[name]);
  gl.uniform1f(kernerlWeightLocation, computeKernelweight(kernels[name]));
  // draw rect 
  var primitiveType = gl.TRIANGLES;
  var offset = 0;
  var count = 6;
  gl.drawArrays(primitiveType, offset, count);
}

```

`gl.bindFramebuffer`를 `null`로 호출하는 것은 WebGL에 프레임 버퍼중 하나에 프레임 버퍼 중 하나 대신에 캔버스에 렌더링 되길 원하는 것을 의미합니다.

### FrameBuffer 작동 확인
프레임버퍼는 첨부된 파일에 따라 동작하지 않을 수 있음. 항상 작동해야하는 첨부물의 타입과 조합 목록이 있음. 여기서 사용된 ==RGBA==/==UNSIGNED_BYTE== 텍스쳐는 ==COLOR_ATTECHMENT0== 첨부 포인터에  할당되어 항상 작동한다고 가정함. 

더 실험적인 텍스쳐 포맷 및 첨부물 조합들은 작동하지 않을 수 있음. 
이러한 경우 프레임버퍼를 바인드 한 다음, ==gl.checkFramebufferStatus==를 호출하고 ==gl.FRAMEBUFFER_COMPLETE==를 리턴하는지 확인하고, 작동하지 않는 다면 알림

WebGL은 [클립 공간](https://webgl2fundamentals.org/webgl/lessons/ko/webgl-fundamentals.html)에서 픽셀로 변환을 합니다. 이 작업은 `gl.viewport` 설정을 기반으로합니다. 프레임버퍼는 캔버스와 크기가 다르기 떄문에 텍스쳐 또는 캔버스에 렌더링 할 것인지에 따라 뷰포트를 적절히 설정할 필요 있음.

```cs title:"Vertex Shader"
	uniform float u_flipY;
	... //
	void main() {
	  ...
	   gl_Position = vec4(clipSpace * vec2(1, u_flipY), 0, 1);
	  ...
	}

```

```cs title:"Fragment Shader"
  ...
  var flipYLocation = gl.getUniformLocation(program, "u_flipY");
  ...
  // 뒤집지 않는다.
  gl.uniform1f(flipYLocation, 1);
  ...

  // 뒤집는다
  - gl.uniform1f(flipYLocation, -1);
  - 
```