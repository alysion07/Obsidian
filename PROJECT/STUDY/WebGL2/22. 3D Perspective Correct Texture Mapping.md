vertex shader가 3번 호출되면 WebGL은 TRIANGLE을 그린다. 해당 삼각형을 그리는 동안 Fragment Shader를 호출해서 해당 픽셀을 어떤 색상으로 칠 할 것인지 결정한다. 삼각형의 세개의 정점 사이에서는 값이 보관된 varying이 전달된다.

![[Pasted image 20240813154127.png|]]
위 렌더링은 `brightness`가 0인 왼쪽은 검은색이고 `brightness`가 1인 오른쪽은 빨간색이며, 그 사이의 삼각형은 `brightness`가 보간된(varying된) 두 개의 직사각형이다.

이전 [[12. 3D Perspective]]에서 WebGL이 우리가 입력한 `gl_Position`을 가져와 `gl_Position.w`로 나눈다는 것을 알고 있다.

위의 정점들에는 `W`에 `1`을 설정했지만 WebGL이 `W`로 나누는 걸 알고 있기 때문에 아래와 같이 해도 동일한 결과를 얻을 것이다.
![[Pasted image 20240813154513.png|center]]

`x`, `y`에 `mult`가 곱해져 있지만 `w`로 나누기 때문에 동일할 것으로 예상했지만 결과가 다르다.  `x`, `y` 의 위치가 그대로 이지만 색상이 다르다. 
![[Pasted image 20240813154605.png]]WebGL은  `w`를 사용하여 **원근 교정 텍스처 매핑을 구현**하거나, `varying`의 **원근 교정 보간**을 수행한다.


```js hl:14,15
#version 300 es
 
in vec4 a_position;
in vec2 a_texcoord;
 
uniform mat4 u_matrix;
 
out vec2 v_texcoord;
 
void main() {
  // position에 행렬을 곱함
  gl_Position = u_matrix * a_position;
 
  // 직접 W로 나누기
  gl_Position /= gl_Position.w;
 
  // 프래그먼트 셰이더로 texcoord 전달
  v_texcoord = a_texcoord;
}
```

`W`로 나누면 `gl_Position.w`는 결국 1이 됩니다. `X`, `Y`, `Z`는 WebGL이 나누기를 수행한 것과 동일한 값이 나올 겁니다. 아래는 그 결과입니다.

![[Pasted image 20240813155013.png]]

**여전히 3D 큐브를 얻게 되지만 텍스처가 뒤틀리고 있습니다.** 이는 이전처럼 `W`를 전달하지 않으면 WebGL이 원근 교정 텍스처 매핑을 할 수 없기 때문입니다. 좀 더 정확하게는 WebGL이 varying의 원근 교정 보간을 수행할 수 없습니다.

[원근 투영 행렬](https://webgl2fundamentals.org/webgl/lessons/ko/webgl-3d-perspective.html)에서 `Z`값이 `W`였던 걸 떠올려보면, `W`가 `1`인 경우 WebGL은 그냥 선형 보간을 수행하게 됩니다. 실제로 위의 수식을 가져와 봅시다.

## summary

이제 왜 WebGL이 4x4 행렬과 `X`, `Y`, `Z`, `W` 4개의 값으로 구성된 벡터를 사용하는지 이해가 되셨으면 좋겠습니다. `X`와 `Y`는 `W`로 나누어 클립공간 좌표를 얻습니다. `W`로 나누는 `Z`도 클립공간의 `Z` 좌표가 됩니다. 하지만 **`W`는 varying의 보간에도 사용되어** **원근 교정 텍스처 매핑이 가능하도록 합니다.**