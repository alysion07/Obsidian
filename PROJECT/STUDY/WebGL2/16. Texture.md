
**Texture**: Shader에 넘길 수 있는 2D 배열 데이터

## Texture 적용 순서

### 1.  Shader로 Textrue Coordinate 전달

```glsl title:'Vertex Shader' hl:2,9
in vec4 a_position;
in vec2 a_texcoord;

uniform mat4 u_matrix;

void main() {
  gl_Position = u_matrix * a_position;
  
  v_texcoord = a_texcoord;
}

```

Fragmen Shader에서 텍스쳐를 참조할 수 있도록 `uniform sampler2D` 선언
정점 쉐이더에서 넘어온 텍스쳐 좌표를 사용할 것이고, 텍스쳐로부터 해당하는 색상값을 찾아내기 위해 ***`texture` 함수***를 호출

```glsl title:'Fragment Shader' hl:2,5 ar:9
#version 300 es
precision highp float;
in vec2 v_texcoord;

uniform sampler2D u_texture;

void main() {
  // call texture function
  outColor = texture(u_texture, v_texcoord);
}
```

#### Texture Coordinate

Texture는 **Texture Coordinate**를 사용해 참조됨 
- Left -> Right = 0.0 -> 1.0
- 첫 줄 -> 마지막 줄 = 0.0 -> 1.0 

첫 줄, 마지막 줄이라는 용어 사용 이유: Texture 공간에서는 **위, 아래의 개념이 없기 때문**
- 데이터의 시작 -> 마지막 = **0.0 -> 1.1**
![[texture-coordinates-diagram.svg|center|400]]

#### Convert to Texture Coordinate

```js title: 
texcoordX = pixelCoordX / (width -1)
texcoordY = pixelCoordY / (height -1)

// example textrure coordi
// 왼쪽 기둥 앞면
 38 / 255,  44 / 255,  // 0.149, 0.172
 38 / 255, 223 / 255,  // 0.149, 0.874
```

- 텍스처 좌표가 **0.0 ~ 1.0 범위 밖의 값**을 가진 다면 텍스처를 **반복**한다.
- `CLAMP_TO_EDGE`를 사용해 특정 방향에 대해 **반복하지 않도록** 설정 가능
- `gl.MIRRORED_REPEAT`: 반복시 텍스처를 Mirror로 설정

---

### 2. Image Load

이미지 로딩은 **비동기적**으로 수행됨.  로딩을 요청하면 브라우져가 다운로드하는데 시간이 소요됨. 해결 방안은 크게 2가지가 있으며 두번째 방법(Shimmer Texture)을 사용하여 연습

1. 다운로드 완료 시점까지 화면 렌더링 **대기** 
2. **Shimmer Texture** 생성

#### Shimmer Texture

`image`가 로드되기 전까지 임시로 1x1 사이즈의 blue 컬러를 채워 넣고, 다운로드가 완료되면 `image`를 텍스쳐에 복사해 넣는다. 

```js title:Shimmer  hl:18,4-13 ar:2,19
var texture = gl.creatTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);

gl.texImage2D(
	gl.TEXTURE_2D,   // target
	0,               // level
	gl.RGBA,         // internalformat
	1,               // width
	1,               // height
	0,               // border
	gl.RGBA,           // format
	gl.UNSIGNED_BYTE,  // type
	new Uint8Array([0, 0, 255, 255])); // rgba- blue color

// load iamge async
var image = new iamge();
image.src = "resource/f-texture.png";
iamge.addEventListener('load', function() {
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.UNSINGED_BYTE, image);
  gl.generateMipmap(gl.TEXTURE_2D);
});
```


--- 

#### Texture Mipmap

크기가 다른 텍스처를 폴리곤에 입혀서 그리려는 경우, 폴리곤의 크기에 맞추어 텍스쳐 픽셀의 평균값을 내는 작업은 GPU에서 너무 느린 작업임

- GPU 에서는 **밉맵(Mipmap)** 을 사용하여 문제 해결 
- 밉맵은 점차적으로 작아지는(**1/4씩 크기가 줆**) 이미지의 집합
- 일반적으로 작은 크기의 텍스처는 이전 레벨로부터 **쌍선형 보간(Bilinear interpolation)** 하여 만들어짐 

![[Pasted image 20240726095204.png|center]]
<center>16X16 픽셀 텍스처에 대한 밉맵</center>
##### `gl.generateMipmap`

가장 큰 레벨을 보고 가장 작은 밉맵을 만들어 줌. 작은 레벨별 밉맵을 직접 입력 가능 
- WebGL2에서는 텍스처들이 **'TextureComplete'** 이여야  함. 아닐 경우 렌더링 안됨
- 가장 쉬운 방법은 `gl.generateMipmap` 호출
##### Teture Filtering
- `NEAREST`: 가장 **큰** 밉맵에서 **1**개의 픽셀을 선택
- `LINEAR`: 가장 **큰** 밉맵에서 **4**개 픽셀을 선택하고 블렌딩
- `NEAREST_MIPMAP_NEAREST`: 가장 적절한 밉맵을 선택, **1**개의 픽셀을 선택
- `LINEAR_MIPMAP_NEAREST`: 가장 적절한 밉맵을 선택하고 **4**개 픽셀을 블렌딩
- `NEAREST_MIPMAP_LINEAR`: 가장 적절한 두 개의 밉맵을 선택, 각 **1**개씩 픽셀 블렌딩
- `LINEAR_MIPMAP_LINEAR`: 가장 **적절한 두 개**의 밉맵을 선택, 각 **4**개씩의 픽셀 블렌딩

필터링 모드를 설정하기 위해서는 아래처럼 `gl.texParameter`를 호출

```CPP
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
```

- `TEXTURE_MIN_FILTER`: 그리려고 하는 크기가 가장 큰 밉맵보다 작을 경우
- `TEXTURE_MAG_FILTER`: 그리려고 하는 크기가 가장 큰 밉맵보다 큰 경우 
- `TEXTURE_MAG_FILTER`: `NEAREST`와 `LINEAR`만 설정 가능
##### 밉맵의 중요성
`NEAREST`, `LINEAR`을 사용하면 가장 큰 이미지로부터 픽셀값을 선택하기 때문에 Flickering 현상이 많이 발생함 

아래 이미지는 설정된 필터링에 따라 어떤 밉맵이 선택되는지 보여준다

<center>NEAREST, LINEAR, NEAREST_MIPMAP_NEAREST</center>
![[Pasted image 20240726102325.png|center|400]]
<center>LIN_MIP_NEAR, NEAR_MIP_LIN, LIN_MIP_LIN (약어)</center>
![[Pasted image 20240726102335.png|center|400]]

##### `LINEAR_MIPMAP_LINEAR`이외의 옵션이 필요한 이유
- LINEAR_MIPMAP_LINEAR 가장 **느림**  (텍스처 1개당 8개의 픽셀 읽음)
- 특정한 효과 기대 -  레트로_한 픽셀화 효과를 얻기 위해서는 `NEAREST`를 사용해야만 함
- 작은 크기 밉맵을 생성하기 위해 **33% 더 많은 메모리 공간을 필요**로 함.가장 큰 밉맵만 사용한다면 그냥 `NEAREST`나 `LINEAR`를 사용(생성 x)

##### Texture Complete
1. 필터링 방법을 유저가 설정하여 **가장 큰 밉맵**만 사용하는 경우 즉, `TEXTURE_MIN_FILTER`를 `LINEAR` 또는 `NEAREST`로 설정한 경우.
2. 밉맵 사용시 그 크기가 적절(?)하고 1X1 크기까지 **모든 밉맵을 제공**하는 경우

#generateMipmap #mipmap
 
 ---

#### Textrue Atlas

 여러 장의 이미지를 하나의 텍스처로 만드는 것
 
##### 장점
 - 텍스처를 한장만 로드, 참조하면 됨 -> 쉐이더가 단순해 짐

![[Pasted image 20240726084401.png]]

---

### UV vs Texture Coordinate

Texture Coordinate는 Texture Coord, texcoods 또는 UV로 줄여쓰기도 함
- vertex Position: `x, y, z, w`
- texture coordianate: `s, t, u, v`  

Texture Wrap Setting: `TEXTURE_WRAP_S`와 `TEXTURE_WRAP_T`를 사용 
\

> [!NOTE] 
> ==UV== == Texture Coordinate
> 
> 
