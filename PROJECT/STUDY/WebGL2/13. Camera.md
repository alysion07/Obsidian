
## viewProjection

원점에서부터 원하는 위치와 방향으로 **이동하고 회전하는 행렬**을 얻으면, 그 **역행렬**을 사용해 나머지 모든 물체를 그 **반대 방향**으로 이동하고 회전하여 마치 카메라가 (0, 0, 0)위치에 있는 것처럼 할 수 있다.

```js title:drawScene() hl:14,15,17-20 ar:18,20
    function drawScene() {
      var numFs = 5;
      var radius = 200;
    ...
    // resize
    // initial
	...
      //compute the matrix
      var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
      var zNear = 1;
      var zFar = 2000;
      var projectionMatrix = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);

      var cameraMatrix = m4.yRotation(cameraAngleRadians);
      cameraMatrix = m4.translate(cameraMatrix, 0, 0, radius * 1.5);

      // make a view matrix from the camera matrix
      var viewMatrix = m4.inverse(cameraMatrix);
      // move the projection space to view space(the space in front of the camera)
      var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);

      // draw  'F's in a circle
      for (var ii = 0; ii < numFs; ++ii) {
        var angle = ii * Math.PI * 2 / numFs;

        var x = Math.cos(angle) * radius;
        var z = Math.sin(angle) * radius;
        // add in the translat for this 'F'
        var matrix = m4.translate(viewProjectionMatrix, x, 0, z);

        // set the matrix
        gl.uniformMatrix4fv(matrixLocation, false, matrix);

        // draw the geometry.
        var primitiveType = gl.TRIANGLES;
        var offset = 0;
        var count = 16 * 6;
        gl.drawArrays(primitiveType, offset, count);
      }
    }
}
```

#### Detail 

Projection Matrix를 계산한 뒤에 'F' 주위를 이동하는 카메라를 계산한다.

```js title:'compute the camera's matrix'
  var cameraMatrix = m4.yRotation(cameraAngleRadians);
  cameraMatrix = m4.translate(cameraMatrix, 0, 0, radius * 1.5);
```

```js title:'Make a view matrix from the camera matrix.'
  var viewMatrix = m4.inverse(cameraMatrix);
```

```js title:'create a viewProjection matrix'
  // create a viewProjection matrix. This will both apply perspective
  // AND move the world so that the camera is effectively the origin
  var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);
```

```js title:"'F'를 배치할 좌표 계산"
    var x = Math.cos(angle) * radius;
    var z = Math.sin(angle) * radius;
    var matrix = m4.translate(viewProjectionMatrix, x, 0, z);
```

좌표 계산 참고 
![[Pasted image 20240723104450.png|center|250]]


## Camera LookAt

카메라가 특정 오브젝트를 바라보게하는 Matrix를 말함, 카메라가 바라보는 방향은 **-Z Axis** 

- **`cameraPosition`:** 원하는 카메라의 위치 
- **`target`:** 카메라가 바라볼 위치 
- **`zAxis`:**  카메라가 `target`을 향하는 vector

---
### Camera Z Axis 계산 

`target`에서 `cameraPosition`를 빼면 카메라로부터 `target`을 행하는 벡터를 구할 수 있다. 카메라가 **-Z방향**을 바라보아야 하기에 c.P에서 t를 빼준다. `cameraPosition - target`
구한 벡터를 정규화해서 행렬의 **`z`** 위치에 놓는다.
- 정규화된 벡터는 **단위 구** 위의 **한 점**을 정의

$$ \begin{pmatrix}  
  &   &   &  \\  
  &   &   &   \\ 
 Zx &  Zy &  Zz &  \\
  &   &   &   \\
\end{pmatrix} 
$$

![[msedge_UNwWxFoPEm.gif|center]]

### Camera X Axis 계산

두 벡터의 **외적(cross product)** 을 계산하면 두 벡터와 **직교**하는 벡터를 얻을 수 있다.
어떤 **순서**로 외적을 계산하느냐에 따라 **X축, -X**축 중 어느 벡터를 얻느냐가 결정됨.
즉, 카메라의 `zAxis`와 `up`의 외적을 계산하면, **`xAxis`** 을 얻을 수 있다!

- `up` cross `zAxis` = **xAxis**
$$ \begin{pmatrix}  
Xz & Xy & Xz &  \\  
  &   &   &   \\ 
 Zx &  Zy &  Zz &  \\
  &   &   &   \\
\end{pmatrix} 
$$
 
![[msedge_T98wzaK8KA.gif|center]]

### Camera Y Axis 계산

`xAxis`를 얻었기 때문에 `zAxis`와 `xAxis`를 외적하면 카메라의 **`yAxis`** 를 얻을 수 있다.
- ` zAxis` cross `xAxis` = **`yAxis`**

$$ \begin{pmatrix}  
Xz & Xy & Xz &  \\
Yx & Yy & Yz &  \\ 
Zx & Zy & Zz &  \\
  &   &   &   \\
\end{pmatrix} 
$$

![[msedge_6WFCYnpPeW.gif]]

## Summary 

##### **viewProjection** Matrix

- 실제로는 세계를 카메라 앞으로 이동시키는 것
- 투영(Projection) 방법은 원점에서 **-Z**축 방향으로 물체가 앞에 있어야 하는 조건.
- **역행렬(inverse Matrix)** 을 사용하여, World를 카메라 앞으로 옮김

##### **lookAt** Matrix
###### Axis 계산 
- **`zAxis`** = `cameraPosition - target` 
- **`xAxis`** = `up` cross `zAxis`
- **`yAxis`** = `zAxis` cross `xAxis`
###### Matrix 
$$
\begin{pmatrix}  
Xx & Xy & Xz & 0 \\ 
Yx & Yy & Yz & 0 \\ 
Zx & Zy & Zz & 0 \\
Tx & Ty & Tz & 1 \\
\end{pmatrix} 
$$

