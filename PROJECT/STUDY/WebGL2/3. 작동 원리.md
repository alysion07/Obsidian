# GPU가 하는일
---
1. Vertex or Data Stream을 처리하여 Clip Space의 정점으로 변환하는 것
2. 위 결과를 가지고 Pixel을 그리는 것

아래 코드 실행 시 
```js
gl.drawArrays(gl.TRIANGLE, 0, 9)
```

위 코드의 '9'의 의미는 '9개의 vertex 처리'

![[vertex-shader-anim.gif | center ]]

`TRIANGLES`을 그리는 경우 GPU는 3개의 정점을 생성할 때마다 삼각형을 만든다. 
어떤 Pixel들이 삼각형의 3개의 점에 해당하는지 확인하고, 삼각형을 'Rasterize'한다. 각 Pixel 마다 F.S(FragmentShader)를 호출하여 어떤 색상으로 그리기 원하는지 알아낸다. F.S는 해당 Pixel에 대해 원하는 색상을 vec4로 출력한다.

Vertex Shader에서 Fragment Shader로 전달하고자 하는 값을 "varying"으로 정의할 수 있다.

```js title:'Triangle Coordi'
function setGeometry(gl) {
	gl.bufferData(
	gl.ARRAY_BUFFER, 
	new Float32Array([
		0, -100,
		150, 125,
		-175, 100]),
		gl.STATIC_DRAW);
}
```

```js title='Draw 3 Vertex'
function drawScene() {
	...
	// geometry 그리기 
	gl.drawArrays(gl.TRIANGLE, 0 , 3);
}
```

```cs title:'Vertex Shader Code'
out vec4 v_color;
...
void main() { 
	gl_Position = vec4((u_matrix * vec3(a_position, 1 )).xy, 0, 1);
	// Convert from clip space to color space.
	// Clip space goes -1.0 to +1.0
	// Color space goes from 0.0 to 1.0
	v_color = gl_Position * 0.5 + 0.5;
	}
```

```cs title:'Fragment Shader Code'
#version 300 es
precision highp flaot;

in vec4 v_color;
out vec4 outColor;

void main() { 
	outColor = v_color;
}
```

 WebGL이 VertexShader에 정의된 varying과 동일한 이름과 타입을 갖는 FragmentShader의 varying을 연결해준다. 
![[fragmentshader.gif  | center | 700 ]]

<center>v_color is interpolated between v0, v1 and v2</center>


attribute를 추가하여  vertext shader에 전달


``` cs hl:2 ar:9 title:'varying Example'
- in vec2 a_position;
- in vec4 a_color;
- ...
- out vec4 v_color;

- void main() {
- ...
- // attribute로부터 varying으로 색상을 복사함.
- v_color = a_color;
- }
```

```js 
// 정점 데이터가 필요한 위치를 찾습니다.
var postionLocation = gl.getAttribLocation(program, "a_position");
var colorLocation = gl.getAttribLocation(program, "a_color");
...
//색상을 위한 버퍼를 생성함
var buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

// 색상을 설정
setColor(gl);

//attributes 설정
...
// 현재 ARRAY_BUFFER에서 데이터를 가져 온느 방법을 색상 attrubute에게 알려준다
gl.enableVertexAttribArray(colorLocation);
var size = 4;
var type = gl.FLOAT;
var normalize = false;
var stride = 0;
var offset = 0;
gl.vertexAttribPointer(colorLocation, size, type, normalize, stride, offset);

// 사각형을 구성하는 2개의 삼각형의 색상으로 버퍼를 채운다.
function setColors(gl) {
	// pick 2 random color
	var r1 = Math.random();
	var g1 = Math.random();
	var b1 = Math.random();
	
	var r2 = Math.random();
	var g2 = Math.random();
	var b2 = Math.random();
	gl.bufferData(
		gl.ARRAY_BUFFER, 
		new Float32Array(
		[ r1, b1, g1, 1,
		  r1, b1, g1, 1,
		  r1, b1, g1, 1,
		  r2, b2, g2, 1,
		  r2, b2, g2, 1,
		  r2, b2, g2, 1]),
		gl.STATIC_DRAW);
	)
}

```

## Buffer & Attribute
---

> **Buffer** : vertex 및 추가적인 정점별 데이터(per-vertex data)를 GPU로 전달하는 방법


- `gl.createBuffer` : 버퍼를 생성한다.
- `gl.bindBuffer` : 버퍼를 작업 할 버퍼로 설정함
- `gl.bufferData` : 데이터를 현재 버퍼로 복사한다.

데이터가 버퍼에 들어간 후에는, WebGL에게 데이터를 가져오는 방법과 V.S의 attribute로 제공하는 방법을 알려주어야 함.

이를 위해 먼저 WebGL에 어떤 위치에 attribute가 할당되어 있는지 물어봅니다. 예를 들어 위의 코드에서는 다음과 같습니다.

``` js
// 정점 데이터가 어디로 전달되어야 하는지 찾습니다.
var positionLocation = gl.getAttribLocation(program, "a_position");
var colorLocation = gl.getAttribLocation(program, "a_color");
```

attribute의 위치를 알게 되면 두 개의 명령문을 실행합니다.

```js
gl.enableVertexAttribArray(location);
```

이 명령문은 WebGL에게 우리가 버퍼로부터 데이터를 제공 할 것이라는 것을 알려줍니다.

```js
gl.vertexAttribPointer(
    location,
    numComponents,
    typeOfData,
    normalizeFlag,
    strideToNextPieceOfData,
    offsetIntoBuffer);
```

위 명령문을 통해 WebGL에게 gl.bindBuffer 에 마지막으로 바인딩 된 버퍼에서 데이터를 가져오도록 함.  컴포넌트의 갯수(numComponents), 타입, stride, offset(`BYTE`, `FLOAT`, `INT`, `UNSIGNED_SHORT`, ...)등을 알려준다. 

컴포넌트의 수는 항상 1에서 4 사이입니다.

각 데이터마다 1개의 버퍼를 사용하는 경우 stride와 offset 모두 항상 0이됩니다.
stride가 0이라는 것은 의미는 "타입과 크기가 일치하는 stride 사용"을 의미합니다.
offset이 0이라는 것은 버퍼의 시작점에서 데이터를 가져온다는 것을 의미합니다.


> [!NOTE] NOTE
> 
> ### vertexAttribPointer의 normalizeFlag는 뭘까?
> **normalizeFlag**는 부동 소수점이 아닌 타입을 위한 플래그
> `false`인 경우  타입 그대로 해석됨.
>  - `BYTE`: -128에서 127까지, 
>  - `UNSIGNED_BYTE`:  0에서 255까지 
>  - `SHORT`: -32768에서 32767까지 
>
> normalizeFlag의  가장 일반적인 용도는 **Color**
>  대부분의 경우 색상은 '0.0~1.0' 사이의 값으로 정의됨.
>  R, G, B 그리고 A에 대해 완전한 부동 소수점을 사용하면 각 정점의 각 색상을 위해 '16byte'를 사용하게 됨.
>  
>그 대신 색상들을 '0' -> '0.0'으로, '255' -> '1.0'을 표현하는 `UNSIGNED_BYTE`로 변환 할 수 있습니다. 이제 정점당 색상에  '4byte'만 필요하므로 **75%의 메모리 절감 효과**가 있습니다.


``` js hl:2,3
  var size = 4;
  var type = gl.UNSIGNED_BYTE;
  var normalize = true;
  var stride = 0;
  var offset = 0;
  gl.vertexAttribPointer(colorLocation, size, type, normalize, stride, offset);
```

```js title:'버퍼를 색상으로 채울 때'
- // 사각형을 구성하는 두 개의 삼각형의 색상으로 버퍼를 채움
- function setColors(gl) {
- // 2 개의 랜덤 색상 선택
- var r1 = Math.random() * 256; // 0 에서 255.99999 사이의 값.
- var b1 = Math.random() * 256; // 이 값들은
- var g1 = Math.random() * 256; // Uint8Array에 저장될 때
- var r2 = Math.random() * 256; // 절단이 발생함
- var b2 = Math.random() * 256;
- var g2 = Math.random() * 256;

- gl.bufferData(
- gl.ARRAY_BUFFER,
- new Uint8Array( // Uint8Array
- [ r1, b1, g1, 255,
- r1, b1, g1, 255,
- r1, b1, g1, 255,
- r2, b2, g2, 255,
- r2, b2, g2, 255,
- r2, b2, g2, 255]),
- gl.STATIC_DRAW);
- }
```

#normalizeFlag #vertexAttribPointer