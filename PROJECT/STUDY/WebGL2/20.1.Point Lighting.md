#point #lighting

3차원 공간상의 한 점에 존재하는 조명을 가정하고 모델 표면의 특정 부분을 비추는 조명
![[스크린샷 2024-08-06 135512.png|center]]

surface의 normal과 각 Light Vector를 **내적**하면 각각 표면 위치에서는 다른 결과값이 계산된다.

먼저 조명의 위치가 필요하다.
```cpp 
uniform vec3 u_lightworldPosition;
```

world 상의 surface coordi 
-> _line 22_:  surface의 `position`을 `world matrix` 로 곱하면 됨.

```cpp title:'vertex shader "get surface to light"' hl:5,7,12,21-25 ar:22
#version 300 es
in vec4 a_position;
in vec3 a_normal;
 
uniform vec3 u_lightWorldPosition;
 
uniform mat4 u_world;
uniform mat4 u_worldViewProjection;
uniform mat4 u_worldInverseTranspose;
 
out vec3 v_normal;
out vec3 v_surfaceToLight;
 
void main() {
  // 위치값을 행렬과 곱해줍니다
  gl_Position = u_worldViewProjection * a_position;
 
  // 법선의 방향을 바꾸어 프래그먼트 셰이더로 전달합니다.
  v_normal = mat3(u_worldInverseTranspose) * a_normal;
 
  // 표면의 월드 공간상 위치를 계산합니다.
  vec3 surfaceWorldPosition = (u_world * a_position).xyz;
 
  // 표면에서 조명을 향하는 벡터를 계산하고 프래그먼트 셰이더로 전달합니다.
  v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;
```


```cpp title:'fragment shader' hl:5,21 er:7,20
#version 300 es
precision highp float;
// 정점 셰이더에서 넘어온 값
in vec3 v_normal;
in vec3 v_surfaceToLight;
 
//uniform vec3 u_reverseLightDirection;
uniform vec4 u_color;
 
// 프래그먼트 셰이더에서는 출력값을 선언해야 합니다.
out vec4 outColor;
 
void main() {
  // v_normal은 보간되는 varying 이기 때문에 단위 벡터가 아닙니다.
  // 정규화를 해야 다시 단위 벡터가 됩니다.
  vec3 normal = normalize(v_normal);
 
  vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
 
//float light = dot(v_normal, u_reverseLightDirection);
  float light = dot(v_normal, surfaceToLightDirection);
 
  outColor = u_color;
 
  // 알파를 제외한 색상 부분만 light값을 곱해줍니다.
  outColor.rgb *= light;
```

## Specular Highlighting (반사 하이라이트)


![[Pasted image 20240806153041.jpg|center]]
surface에서 반사된 빛(**A**) 의 **reflection**(**B**)이 surface와 눈의 **각도**와 **일치**하면 위 이미지와 같은 반사광을 볼 수 있다.

![[Pasted image 20240806160212.png|center|400]]


모델의 표면에서 조명을 향하는 방향을 알 수 있다면 (위에서 이미 계산 한 값), 그리고 표면에서 뷰/눈/카메라를 향하는 방향을 알 수 있다면(우리가 계산 가능한 값), 이 두 벡터를 더하고 정규화해서 `halfVector`라 불리는 백터를 얻을 수 있다.
![[Pasted image 20240806161006.png|center|400]]

- `halfVector`: `surface2view`, `surface2light` 두 백터의 중간에 위치한 백터, 빛이 눈으로 완벽하게 반사되는 각도라는 의미. 두 백터를 더하고 정규화해서 구할 수 있다.

```cpp
vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);
```
-  내적 결과값
	- **` 1`**: 동일 방향
	- **` 0`**: 수직 방향
	- **`-1`**: 반대 방향

### How

view / eye / camera 위치를 전달하고, surface에서 view를 향하는 벡터 `surface2view`를 구한 후, `fragment shader`로 전달한다. 

기존 코드에서 view의 world position을 넘겨줄 수 있도록 수정
```cpp title:'vertex shader' hl:2,6,12,13
uniform vec3 u_lightWorldPosition;
uniform vec3 u_viewWorldPosition;
...
out vec3 v_normal;
out vec3 v_surfaceToLight;
out vec3 v_surfaceToView;
...

void main {
...
// 표면에서 뷰/카메라를 향하는 벡터를 계산하고 프래그먼트 셰이더로 전달합니다.
v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;
}
```

```cpp title:'fragment shader' hl:3,10-12,15,23
in vec3 v_normal;
in vec3 v_surfaceToLight;
in vec3 v_surfaceToView;
...
void main() {
  // v_normal은 보간되는 varying 이기 때문에 단위 벡터가 아닙니다.
  // 정규화를 해야 다시 단위 벡터가 됩니다.
  vec3 normal = normalize(v_normal);
 
  vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
  vec3 surfaceToViewDirection = normalize(v_surfaceToView);
  vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);
 
  float light = dot(normal, surfaceToLightDirection);
  float specular = dot(normal, halfVector);
 
  outColor = u_color;
 
  // 알파를 제외한 색상 부분만 light값을 곱해줍니다.
  outColor.rgb *= light;
 
  // specular 값을 더해줍니다.
  outColor.rgb += specular;
}

```

fragment shader 에서는 `surfaceToView`, `surfaceToLight`의 사이 백터인 `halfVector`를 계산해야 한다.