#point #lighting

3차원 공간상의 한 점에 존재하는 조명을 가정하고 모델 표면의 특정 부분을 비추는 조명
![[스크린샷 2024-08-06 135512.png|center]]

surface의 normal과 각 Light Vector를 **내적**하면 각각 표면 위치에서는 다른 결과값이 계산된다.

먼저 조명의 위치가 필요하다.
```cpp 
uniform vec3 u_lightworldPosition;
```

그리고 `surface`의 월드 공간상의 위치를 계산할 수 있는 방법이 필요함

-> _line 22_:  `surface`의 `position`을 `world matrix` 로 곱하면 됨.

```cpp title:'vertex shader "get surface to light"' hl:5,7,12,21-25 ar:22
#version 300 es
in vec4 a_position;
in vec3 a_normal;
 
uniform vec3 u_lightWorldPosition;
 
uniform mat4 u_world;
uniform mat4 u_worldViewProjection;
uniform mat4 u_worldInverseTranspose;
 
out vec3 v_normal;
out vec3 v_surfaceToLight;
 
void main() {
  // 위치값을 행렬과 곱해줍니다
  gl_Position = u_worldViewProjection * a_position;
 
  // 법선의 방향을 바꾸어 프래그먼트 셰이더로 전달합니다.
  v_normal = mat3(u_worldInverseTranspose) * a_normal;
 
  // 표면의 월드 공간상 위치를 계산합니다.
  vec3 surfaceWorldPosition = (u_world * a_position).xyz;
 
  // 표면에서 조명을 향하는 벡터를 계산하고 프래그먼트 셰이더로 전달합니다.
  v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;
```


```cpp title:'fragment shader' hl:5,21 er:7,20
#version 300 es
precision highp float;
// 정점 셰이더에서 넘어온 값
in vec3 v_normal;
in vec3 v_surfaceToLight;
 
//uniform vec3 u_reverseLightDirection;
uniform vec4 u_color;
 
// 프래그먼트 셰이더에서는 출력값을 선언해야 합니다.
out vec4 outColor;
 
void main() {
  // v_normal은 보간되는 varying 이기 때문에 단위 벡터가 아닙니다.
  // 정규화를 해야 다시 단위 벡터가 됩니다.
  vec3 normal = normalize(v_normal);
 
  vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
 
//float light = dot(v_normal, u_reverseLightDirection);
  float light = dot(v_normal, surfaceToLightDirection);
 
  outColor = u_color;
 
  // 알파를 제외한 색상 부분만 light값을 곱해줍니다.
  outColor.rgb *= light;
```

## Specular Highlighting (반사 하이라이트)


![[Pasted image 20240806153041.jpg|center]]
surface에서 반사된 빛(**A**) 의 **reflection**(**B**)이 surface와 눈의 **각도**와 **일치**하면 위 이미지와 같은 반사광을 볼 수 있다.

![[Pasted image 20240806160212.png|center|400]]


모델의 표면에서 조명을 향하는 방향을 알 수 있다면 (위에서 이미 계산 한 값), 그리고 표면에서 뷰/눈/카메라를 향하는 방향을 알 수 있다면(우리가 계산 가능한 값), 이 두 벡터를 더하고 정규화해서 `halfVector`라 불리는 백터를 얻을 수 있다.
![[Pasted image 20240806161006.png|center|400]]

- `halfVector`: `surface2view`, `surface2light` 두 백터의 중간에 위치한 백터, 빛이 눈으로 완벽하게 반사되는 각도라는 의미. 
-  내적 결과값
	- **` 1`**: 동일 방향
	- **` 0`**: 수직 방향
	- **`-1`**: 반대 방향

### How

뷰 / 눈 / 카메라의 위치를 전달하고, `surface`에서 `view`를 향하는 벡터를 구한 후, fragment shader로 전달한다. 
```

```
