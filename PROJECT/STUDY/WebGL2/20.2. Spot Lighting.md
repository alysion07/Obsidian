## Basic

Spot Lighting을 구현하기 위해서는 위치를 중심으로 빛이 향하는 특정 방향을 정해야한다. 그리고 빛이 향하는 방향마다 그 방향과 우리가 정한 특정 방향과의 내적을 구한 후 임계값을 기준으로 빛을 비출것인지 결정한다.
![[Pasted image 20240807155705.png|center|450]]
![[Pasted image 20240807160823.png | center|350]]

아래와 같은 체크로 조명효과 계산 가능 
```cpp  title:'Spotlight fragment shader' hl:11,12,26,29-36 ar:32-35
#version 300 es
precision highp float;
 
// 정점 셰이더에서 넘어온 값
in vec3 v_normal;
in vec3 v_surfaceToLight;
in vec3 v_surfaceToView;
 
uniform vec4 u_color;
uniform float u_shininess;
uniform vec3 u_lightDirection;
uniform float u_limit;          // 내적 공간에서의 값
 
// 프래그먼트 셰이더에서는 출력값을 선언해야 합니다.
out vec4 outColor;
 
void main() {
  // v_normal은 보간되는 varying 이기 때문에 단위 벡터가 아닙니다.
  // 정규화를 해야 다시 단위 벡터가 됩니다.
  vec3 normal = normalize(v_normal);
 
  vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
  vec3 surfaceToViewDirection = normalize(v_surfaceToView);
  vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);
//float light = dot(normal, surfaceToLightDirection);
  float light = 0.0;
  float specular = 0.0;
 
  float dotFromDirection = dot(surfaceToLightDirection,
                               -u_lightDirection);
  if (dotFromDirection >= u_limit) {
    light = dot(normal, surfaceToLightDirection);
    if (light > 0.0) {
      specular = pow(dot(normal, halfVector), u_shininess);
    }
  }
  // 중략 
  
```

![[Pasted image 20240807171704.png|center|450]]

몇 가지 확인할 사항이 있다. 먼저 위 코드에서는 `u_lightDirection`의 방향을 **뒤집었다는 점**이다. uniform 값을 설정하는 시점에 방향을 뒤집어서 전달하는 방법도 있겠지만, `u_reverseLightDirection`, `u_negativeLightDirection`의 네이밍보다 이해하기 좋을 것으로 생각됨.
## Shader에서 조건문 사용

개인 선호도에 달린 것이긴 하나, 가능하면 **_shader_** 에 조건문을 사용하지 않으려 한다. 그 이유는 실제로는  **_shader_** 에 조건문이 없기 때문.  **_shader_** 내에서 조건문을 사용하게 되면 컴파일러가 코드를 여기저기 **`0`, `1`** 을 곱하는 식으로 확장해 실제로는 조건문이 업는 형태로 바꾼다. 즉 조건문을 사용하면 조합하는 만큼 코드가 길어진다는 뜻이다. 

```cpp hl:3
  float dotFromDirection = dot(surfaceToLightDirection,-u_lightDirection);
  // spotLight 영역 안이면 inLight는 1이되고 아니면 0이 됩니다.
  float inLight = step(u_limit, dotFromDirection);
  float light = inLight * dot(normal, surfaceToLightDirection);
  float specular = inLight * pow(dot(normal, halfVector), u_shininess);
```


----
## Stop-Lighting Interpolation

![[Pasted image 20240808133532.png|center]]

이미지를 보면 Spotlight의 경계가 매우 거칠다는 것을 볼 수 있다. 하나의 경계만을 사용해 비춤 여부를 결정하기 때문.
`u_inner_Limit`, `u_outerLimit`두 개의 경계를 사용하여,  두 경계 사이의 값은 **interpolation**(보간)하여 조명이 자연스럽도록 개선한다.

내적 결괏값을 **_a_** 라 할 경우 
- **_a_** < `u_inner_Limit`: 최대 밝기로 비춘다.
- `u_inner_Limit`< **_a_** <= `u_outerLimit`: 결괏값을 보간하여  밝기를 조절.
- **_a_** < `u_outerLimit`: 조명을 비추지 않는다.'


---
###### **Math**.cos(rad **_x_**)

**매개변수** 
- **_x_**: 코사인을 계산할 각도를 나타내는 숫자. **radian** 단위로 주어져야 한다.
- 반환 값은  **-1 ~ 1** 사이의 값

**코사인** **함수**
- 코사인 함수는 주기 함수로 주기는 2π 라디안이다. 
- `Math.cos(x)` == `Math.cos(x + 2 * Math.PI)`
- `Math.cos(x) = Math.cos(-x)` 즉, 코사인 함수는 심대칭 함수이다.

```js title:'Math.cos 함수의 역할' hl:2,3
    gl.uniform3fv(lightDirectionLocation, lightDirection);
    gl.uniform1f(innerLimitLocation, Math.cos(innerLimit));
    gl.uniform1f(outerLimitLocation, Math.cos(outerLimit));
```

**0 ~ 180** degree에서 **radian**으로 변환된 값 `innerLimit`를 전달받고, `Math.cos`함수를 사용해  **-1 ~ 1** 범위로 변환한 값을 **shader**로 전달한다.

---

```cpp er:5 hl:1,2,6,7
uniform float u_innerLimit;     // 내적 공간에서의 값
uniform float u_outerLimit;     // 내적 공간에서의 값
 ...
  float dotFromDirection = dot(surfaceToLightDirection,-u_lightDirection);
//float inLight = step(u_limit, dotFromDirection);
  float limitRange = u_innerLimit - u_outerLimit;
  float inLight = clamp((dotFromDirection - u_outerLimit) / limitRange, 0.0, 1.0);
  float light = inLight * dot(normal, surfaceToLightDirection);
  float specular = inLight * pow(dot(normal, halfVector), u_shininess);
```

---
###### **function** `clamp` (genType **_x_**, genType **_minVal_**, genType **_maxVal_**)
 `clamp` returns the value of _`x`_ constrained to the range _`minVal`_ to _`maxVal`_. The returned value is computed as **min**(**max**( _`x`_, _`minVal`_), _`maxVal`_).

---
###### **function** `smoothstep` (genType _edge0_, genType edge1,|||genType x|)
 `smoothstep` performs smooth **Hermite interpolation** between 0 and 1 when _`edge0`_ < _`x`_ < _`edge1`_. This is useful in cases where a threshold function with a smooth transition is desired. 
 
Results are **undefined** if _`edge0`_ ≥ _`edge1`_.

---

## Summary


![[Pasted image 20240808144856.png|center]]

![[Pasted image 20240808144956.png|center]]


- 조명의 방향(`u_lightDirection`)과 표면에서 Light를 가리키는 백터(`u_surfaceToLightDirection`)를 활용해 SpotLighting을 구현할 수 있다.
- **shader**에서 조건문이 늘어날 수록 코드의 길이는 길어지며, `step`과 같은 함수로 대체하여 사용하는 것이 좋다.
- SpotLight의 경계를 2(inner,outer)개 사용하여 Lerp(선형보간)을 사용해 자연스러운 조명 효과를 구현할 수 있다.
