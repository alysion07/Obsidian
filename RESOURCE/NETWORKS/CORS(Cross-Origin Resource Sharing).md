## Basic 

#CORS 는 일종의 방어막. 
이 곳 저 곳에서 가져오는 리소스가 안전하다는 최소한의 보장

*'교차 출처 리소스 공유'* 로 해석되지만, **'교차 출처'** 보다는 **'다른 출처'** 라는 의미로 해석하는 것이 이해하기 쉽다.

### Origin이란 무엇?

서버의 위치를 의미하는 https://google.com 과 같은 URL들은 마치 하나의 문자열 같이 보여도, 사실은 여러개의 구성 요소로 이루어져 있다.

![[Pasted image 20240924085729.png]]

출처는 `protocol`, `host` 위 이미지엔 나와있지 않지만 `:80`, `:443`과 같은 포트 번호 까지 모두 합친 것을 의미한다.  


## SOP(Same-Origin Policy)
 
#SOP

**동일한 출처에서만 리소를 공유할 수 있다.** 는 법률을 의미한다.
즉, 동일출처(Same-Origin) 서버에 있는 리소스는 자유로이 가져올 수 있지만, 다른 출처(Cross-Origin)서버에 있는 이미지나 유튜브 영상 같은 리소스는 상호작용이 불가능 하다는 의미.

![[Pasted image 20241126100551.jpg|CORS 발생 상황|500]]

---

### SOP가 필요한 이유

출처가 다른 두 어플리케이션이 자유로이 소통할 수 있는 환경은 꽤 위험한 환경임.
제약이 없다면 CSRF(Cross-Site Request Fogery)나 XSS(Cross-Site Scripting) 등의 방법을 이용해서 해커가 심어 놓은 코드를 해 개인정보를 가로챌 수 있다.
![[Pasted image 20241126112631.png|SOP가 없는 상황에서의 악의적인 홈페이지 접속 |500]]

1. 사용자가 악성 사이트에 접속
2. 이때 해커가 몰래 심어놓은 악의적인 자바스크립트가 실행되어, 사용자가 모르는 사이에 어느 포털 사이트에 요청을 보낸다.
3. 그럼 포털 사이트에서 해당 브라우저의 쿠키를 이용하여 로그인을 하거나 등 상호작용에 따른 개인 정보를 응답 값을 받은 뒤, 사이트에서 해커 서버(hacker.example.com)로 재차 보낸다.
4. 이외에도 사용자가 접속중인 내부망의 **IP**와 **Port**를 가져오거나, 해커가 사용자 브라우저를 프록시처럼 악용할 수도 있다. 

### 출처 구분 기준 
**Protocol(Scheme), Host, Port** 이 **3가지**가 동일하다면 동일 출처로 판단.

![[Pasted image 20241126113005.png|기준이 되는 출처]]

### 출처 비교와 차단은 브라우저가 수행

출처를 비교하는 로직은 서버에 구현된 스펙이 아닌 **브라우저**에 구현된 스펙이다.

![[Pasted image 20241126113213.png|500]]


> [!Info]
> 그래서 CORS 에러를 해결하는 방안 중 하나로 크롬 브라우저 설정에 SOP 정책을 비활성화 하는 방법이 있긴 한데 권장하지는 않는다.



>[!Tip]
>브라우저가 정책으로 차단을 한다는 말은, ***'브라우저를 통하지 않고 서버 간에 통신을 할때는 정책이 적용되지 않는다'*** 는 말과 같다. 
> 즉, 클라이언트 단 코드에서 API 요청을 하는게 아니라, 서버 단 코드에서 다른 출처의 서버로 API 요청을 하면 CORS 에러로부터 자유로워 진다. 그래서 이를 이용한 프록시(Proxy) 서버라는 것이 있다. (후술)



## 교차 출처 리소스 공유 (Cross-Origin Resource Sharing)

 SOP 정책을 위반해도 CORS 정책에 따르면 다른 출처의 리소스라도 허용 한다는 의미
#### 브라우저의 CORS 기본 동작 살펴보기

1. 클라이언트에서 HTTP 요청의 Header에 Origin을 담아 전달
	1. 웹은 [[HTTP]] Protocol을 이용하여 서버에 요청을 보냄
	2. 이때 브라우저는 요청 Header에 ***Origin*** 이라는 필드에 출처를 함께 담아 보냄

![[Pasted image 20241126114627.png|Origin Field |400]]

2. 서버는 응답 Header에 Access-Control-Allow-Origin을 담아 클라이언트로 전달
	1. 이후 서버가 이 요청에 대한 응답을 할때 응답 헤더에  Access-Contorl-Allow-Origin 이라는 필드를 추가하고 값으로 ***'이 리소스를 접근하는 것이 허용된 출처 url'*** 을 내려보낸다. 

![[Pasted image 20241126115211.png|400]]

3.  클라이언트에서 Origin과 서버가 보내준 Access-Control-Allow-Origin을 비교한다.
	1. 이후 응답을 받은 브라우저는 자신이 보냈던 요청의 Origin과 서버가 보내준 응답의  Access-Contorl-Allow-Orign을 비교해 본 후 차단 여부를 결정
	2. 유효하지 않은 응답인 경우 사용하지 않고 버린다(CORS Error)

### 결국 CORS 해결책은 서버의 허용이 필요

위 CORS 동작을 살펴본 **결론**은 서버에서 `Acces-Control-Allow-Origin` **헤더에 허용할 출처를 기재해서 클라이언트에 응답** 하면 되는 것. 즉 Back-end의 영역

>[!Info]
> 그렇다면 클라이언트에서 미리 자바스크립트로 origin 헤더값을 위조하면 되지 않을까 싶지만, 브라우저에서 이를 감지하여 차단하기 때문에 결론은 불가능하다.
> ![[Pasted image 20241126115926.png]]


## CORS 작동 3가지 시나리오

단순 요청을 떠나 **쿠키**나 **토큰**과 같은 인증 데이터를 다른 출처의 서버에 요청을 해야 한다면 필수적인 지식.
브라우저의 세부적인 CORS 통신 동작 과정을 알고 있어야 최적화 작업이 가능 해진다.

#### 3가지 요청
- 예비요청 (Preflight Request)
- 단순 요청(Simple Request)
- 인증된 요청(Credential Request)

[3가지 요청 체험](https://chuckchoiboi.github.io/cors-tutorial/)

