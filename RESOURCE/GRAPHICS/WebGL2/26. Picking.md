 WebGL은 Rasterization 라이브러리이다. 점, 선, 면을 캔버스에 그리며 객체를 선택한다는 개념이 없다. 제공되는 셰이더를 통해 픽셀만 출력한다. 즉 "선택"이라는 개념은 개발자의 코드로부터 와야 한다. 사용자가 선택하는 것이 무엇인지 정의 해야한다.

## Clicking on an Object

사용자가 어떤 것을 클릭했는지 알아내는 가장 쉬운 방법은 각 객체에 대한 **숫자 ID를 제시**하는 것이다. 그 후, 조명과 텍스쳐 없이 ID를 색상으로 사용하여 모든 객체를 그릴 수 있다.
이렇게 하면 각 개체의 실루엣 이미지를 얻을 수 있다. 이후 Depth 버퍼는 정렬을 수행한다. 그런 다음 마우스 아래 **픽셀의 색상을 읽으면 해당 픽셀에 렌더링 된 객체의 ID를 알 수 있다.**

#### Shader 추가 
오브젝트별로 color id를 부여하기 위해 별도의 셰이더가 필요하다. 


```c title:'Picking Fragmentshader' hl:9,10
#version 300 es
precision highp float;
 
uniform vec4 u_id;
 
out vec4 outColor;

void main() {
    // 전달받는 id 값을 outColor 값으로 사용
    outColor = u_id;
}
```

---
#### 같은 Location을 사용하도록 설정
이 예제는 **2개의 다른 셰이더로 같은 데이터**를 그려야 했던 몇 안 되는 경우 중 하나 이다. 그래서 두 셰이더 간에 attribute의 위치가 일치해야 합니다. 두가지 방법으로 설정할 수 있다.

```c title:'1. set Location Manually in the GLSL'
layout (location = 0) in vec4 a_position;
layout (location = 1) in vec4 a_color;
```


```c title:"2. Call 'gl.bindAttribLocation' before linking" hl:3
gl.bindAttribLocation(someProgram, 0, 'a_position');
gl.bindAttribLocation(someProgram, 1, 'a_color');
gl.linkProgram(someProgram);
```

이를 통해, `a_position` *attribute*가 두 프로그램 모두에서 ***location* 0**을 사용함을 보장할 수 있으므로 **두 프로그램 모두에서 동일한 *vertex array*를 사용할 수 있다.**

#### 같은 위치에 렌더링  

```js title:"rendering object twice"  hl:13,20

  // ------ Draw the objects to the texture --------
 
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
 
  gl.enable(gl.CULL_FACE);
  gl.enable(gl.DEPTH_TEST);
 
  // Clear the canvas AND the depth buffer.
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
 
  drawObjects(objectsToDraw, pickingProgramInfo);
 
  // ------ Draw the objects to the canvas
 
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
 
  drawObjects(objectsToDraw);
```


#### ID를 RGBA로 분리 

텍스쳐의 format/type이 `gl.RGBA`, `gl.UNSIGNED_BYTE`이기 때문에 각 채널당 8bit를 얻는다. **8bit는 256**개의 값만 표현할 수 있지만, ID를 **4개의 채널로 나눠 저장**함으로써 32비트를 얻게 되어, **40억 개 이상**의 값을 나타낼 수 있다.

ID에 1을 더하여 사용하는 이유는 0은 마우스 아래 아무것도 없음을 나타내기 위함.

#### 마우스 커서의 위치 추출

```js title:"get cursor posotion"
let mouseX = -1;
let mouseY = -1;

...
gl.canvas.addEventListner('mousemove', (e) => {
	const rect = canvas.getBoundingClientRect();
	mouseX = e.clientX - rect.left;
	mouseY = e.clientY - rect.top;
})
```

여기서 `mouseX`, `mouseY`는 **디스플레이 공간에서 CSS 픽셀 단위로 되어있다는 점에 유의** 해야 한다. 이는 캔버스가 표시되는 공간의 좌표를 나타내며, 캔버스 자체의 픽셀 수가 아닌 공간을 의미한다. 다시 말해, 만약 다음과 같은 캔버스 공간을 가지고 있다면

```html title:"coordinate"
<canvas width="11" height="22" style="width:33px; height:44px;"></canvas>
```

캔버스 상에서 마우스의 각 축 범위 
- `mouseX`:  `x`축 **0 ~ 33**
- `mouseY`: `y` 축 **0 ~ 44**

상세 내용 링크: [[2. Canvas Resizing]]

#### 마우스 아래 픽셀 찾기
```js title:"look up the pixel under the mouse"
const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
const pixelY = gl.canvas.height - mouseY * gl.canvas.height /  gl.canvas.clientHeight - 1;
const data = new Uint8Array(4);
gl.readPixels(
pixelX,
pixelY,
1,
1,
gl.RGBA,
gl.UNSIGNED_BYTE, 
data);
const id = data[0] +(data[1] << 8 ) + (data[2] << 16) + (data[3] << 24);
```

`pixelX`와 `pixelY`를 계산하여 디스플레이 공간의 `mouseX`, `mouseY`를 캔버스 공간의 pixel로 **변환**한다.

실제 코드에서는 Util 함수 `resizeCanvasToDisplaySize`를 사용하여 텍스쳐의 크기를 캔버스와 동일하게 설정하여 디스플레이의 크기와 캔버스의 크기가 일치하도록 설정하고 있다.

#### 선택된 객체 강조 표시
쉐이더에 선언한 `u_colorMult` 유니폼을 사용해 객체가 아래에 있다면 객체를 찾아 `u_colorMult` 값을 저장하고, 선택 색상으로 대체 한 뒤, 선택 해제 시에는 원래 값을 복원한다. 

```js title:"Highlight selected object" hl:4-6
// mouseX and mouseY는 캔버스에 대한 CSS 화면 공간에 있다.
let mouseX = -1;
let mouseY = -1;
let oldPickIdx = -1;
let oldPickColor;
let frameCount = 0;

// draw the scene
function drawScene(time) {
  time *=0.0005;
  ++frameCount;
  // --- 물체를 텍스쳐에 맞게 그린다 ---
  ...
  // --- 마우스 아래 픽셀을 알아내고 읽는다 ---
  const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
  const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;
  const data = new Uint8Array(4);
  gl.readPixels(
  pixelX,              // x
  pixelY,              // y
  1,                   // width  
  1,                   // height
  gl.RGBA,             // format
  gl.UNSIGNED_BYTE,    // type
  data);               // typed array to hold result
  const id = data[0] + (data[1]  << 8) 
  + (data[2]  << 16) + (data[3]  << 24);

  //restore the object's color 
  if(oldPickIdx >= 0) {
    const object = objects[oldPickIdx];
    object.uniform.u_colorMult = oldPickColor;
    oldPuckIdx = -1;
  }
  
  // Highlight object under mouse
  if(id > 0) {
    const pickIdx = id - 1;
    oldPickIdx = pickIdx;
    const object = objects[pickIdx];
    oldPickColor = object.uniforms.u_colorMult;
    object.uniforms.u_colorMult = 
    (frameCount & 0x8) ? [1,0,0,1]:[1,1,0,1]
  }
}
```

#### ID 값 설정 중 Bit 연산 활용 
```js title:"Bit연산 활용 (오브젝트 생성 중)" hl:7
// make an object.
const object = {
	uniforms: {
		u_color_multiply: chroma.hsv(positiveModulo(baseHue + rand(0, 120), 360), rand(0.5, 1), rand(0.5, 1)).gl(),
	u_matrix: m4.identity(),
	u_id: [
		((id >>  0) & 0xFF) / 0xFF, // 8비트 추출 비트 마스킹
		((id >>  8) & 0xFF) / 0xFF, // 0 ~ 1 사이값으로 정규화
		((id >> 16) & 0xFF) / 0xFF,
		((id >> 24) & 0xFF) / 0xFF,
		],
	},
	translation: [rand(-100, 100), rand(-100, 100), rand(-150, -50)],
	xRotationSpeed: rand(0.8, 1.2),
	yRotationSpeed: rand(0.8, 1.2),
};
objects.push(object);
```

- `>>`:  shift 연산을 통해 하위 8bit 자리로 값을 **이동** 
- `& 0xFF`: 비트마스킹 연산(**`&`**)을 통해 하위 **8bit** 값만 추출(**0xFF**는 256)
- `/ 0xFF`: **`/`** 연산으로 추출한 값을 **0 ~ 1** 사이의 값으로 **정규화**

---
#### frustum culling을 활용한 Picking 최적화 

각 오브젝트에 설정된 `u_id`를  캔버스와 같은 크기의 텍스쳐에 렌더링한다는 부분은 가장 쉬운 최적화 방법이다. 하지만 **frustum projection**을 활용해 마우스 아래 1 pixel만 렌더링 할 수 있다.

일반 투영 행렬을 사용해 객체를 위치시키고, frusum 통한 투영을 한번 더 진행.

**frustum**은 대부분의 3D Math Library에서 제공하며, 
`left`, `right`, `top`, `bottom`, `near`, `far` 값을 입력 받아 projection matrix를 생성함.

이것을 통해 **1 pixel에 대한  projection matrix을 생성**할 수 있다.

또한 `u_marix` uniform을 제거하고,  `viewProjectionMatrix`를 모든 객체가 공유하여,  계산하는 부분을 **vertexShader** 코드로 옮길 수 있게 된다.

```js er:4 hl:5,6 title:"remove u_matrix"
const object = {
  uniform: {
    u_colorMult: chroma.hsv(eMod(baseHue + rand(0, 120), 360),   rand(0.5, 1), rand(0.5, 1)).gl(),
    u_matrix: m4.identity(),
    u_world: m4.identity(),
    u_viewProjection: viewProjectionMatrix,
    u_id: [
      ((id >>  0) & 0xFF) / 0xFF,
      ((id >>  8) & 0xFF) / 0xFF,
      ((id >> 16) & 0xFF) / 0xFF,
      ((id >> 24) & 0xFF) / 0xFF,
     ],},
    // other uniform...
  }
}
```

```js er:1,2 hl:3,4 title:"remove viewProjectionMatrix" 
function computeMatrix(viewProjectionMatrix, translation, xRotation, yRotation) {
  let matrix = m4.translate(viewProjectionMatrix,
function computeMatrix(translation, xRotation, yRotation) {
  let matrix = m4.translation(
      translation[0],
      translation[1],
      translation[2]);
  matrix = m4.xRotate(matrix, xRotation);
  return m4.yRotate(matrix, yRotation);
}
```

```c title:"vertex s and picking vertex s" er:2, hl:3,4
...
uniform mar4 u_matrix;
uniform mat4 u_viewProjection;
uniform mat4 u_world;
...
```

