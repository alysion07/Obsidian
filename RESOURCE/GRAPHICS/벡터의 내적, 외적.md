
참고: https://www.3blue1brown.com/
참고: [13. 벡터의 내적(Dot Product) : 네이버 블로그 (naver.com)](https://blog.naver.com/ideugu/221407625806)
참고: [벡터의 내적 문제에 맞서는 최강의 공식 – 벡터와 중선 | godingMath](https://godingmath.com/vectormedian)

---

## 1. 벡터의 내적

- 벡터의 내적은 같은 차원의 두 벡터가 주어졌을 때 벡터를 구성하는 각 성분을 곱한 후 이들을 더해 스칼라를 만들어 내는 연산이다.
- 컴퓨터에서 사인 이나 코사인 값을 직접 계산하는 것은 큰 연산 비용을 요구한다.  하지만 내적을 사용하면 컴퓨터가 가장 빠르고 잘 할 수 있는 곱셈과 덧셈의 연산 문제로 귀결된다. 따라서 **코사인 함수가 나오는 공식은 모두 내적으로 변경하는 것이 바람직하다.**


```null
u = (a, b)
v = (c, d)
u·v = a·c + b·d
```

- 같은 벡터를 내적하면 벡터의 크기를 제곱한 결과가 나온다.

```null
u = (a, b)
u·u = a·a + b·b = a^2 + b^2
∴ u·u = |u|^2 
```

- 두 벡터의 사잇각을 θ라고 할 때 내적과 cos 함수의 관계는 다음과 같다.

```null
u·v = |u|·|v|·cosθ
```


### 내적을 계산하는 순서는 중요하지 않다

v를 2배로 늘려 대칭이 깨지더라도 이 스케일링이 내적의 값에 미치는 영향은 case1, 2 두 경우 모두에서 **동일**합니다.

case 1. 
![[Pasted image 20240716154417.png|center|500]]
case 2.
![[Pasted image 20240716154423.png|center|500]]

---

### 벡터의 이중성



### 벡터의 내적 활용

#### **1) 앞뒤 판별**

캐릭터의 시선을 u, 캐릭터에서 목표로 향하는 벡터를 v라고 할 때, 두 벡터의 내적 값에 따라 목표가 캐릭터의 앞에 있는지, 뒤에 있는지 파악할 수 있다.
- u·v **>** 0 (cosθ **>** 0 / 두 벡터 사이가 **예각**) : 목표가 캐릭터의 **앞**에 있다.
- u·v **=** 0 (cosθ **=** 0 / 두 벡터 사이가 **직각**) : 목표가 캐릭터의 **옆**에 있다. **직교성 판별** 
- u·v **<** 0 (cosθ **<** 0 / 두 벡터 사이가 **둔각**) : 목표가 캐릭터의 **뒤**에 있다.


![[Pasted image 20240712162945.png]]


#### **2) 시야 판별**

- 시야각이 β이고, 캐릭터의 시선 단위벡터를 u, 캐릭터에서 목표물로 향하는 단위벡터를 v라고 할 때, 두 벡터의 내적 값에 따라 목표가 시야각 내에 있는지, 밖에 있는지 파악할 수 있다.
    - u·v >= cos β/2 : 목표물이 시야 범위 안에 있다.
    - u·v < cos β/2 : 목표물이 시야 범위 밖에 있다.
![[Pasted image 20240716143632.png|center]]

#### **3) 램버트 코사인 법칙(Lambert’s cosine law)**

내적의 두 번째 유용한 성질은 cosθ 값을 몰라도 곱셈과 덧셈으로 이를 구할 수 있다는 것이다. 이 성질은 특히 벡터의 크기가 1일때 유용하다. 벡터의 크기가 1이면 a와 b의 내적은 바로 cosθ가 되기 때문이다.  내적과 밀접한 관련이 있는 cos 함수의 그래프는 다음과 같다. 

![[Pasted image 20240716143108.png|center]]
 

크기가 1인 두 벡터가 있다면 곱셈과 덧셈을 사용해 cosθ 값을 바로 구할 수 있는데, 컴퓨터 그래픽에서 이를 사용하는 대표적인 공식이 램버트 코사인 법칙(Lambert’s cosine law)이다.

![[Pasted image 20240716143051.png|center]]
램버트 코사인 법칙은 표면에 빛이 들어오는 각도에 따라 반사되는 세기는 cos 함수에 비례한다는 단순한 법칙이다.
  
이의 값을 구할 때 코사인 함수 값을 구하지 않고 표면이 향하는 노멀 벡터(N)과 빛으로 향하는 벡터(L)를 구한 후 두 벡터의 내적을 사용하면 컴퓨터로 빠르게 계산할 수 있다.  

이를 사용하는 셰이딩 모델을 **Diffuse Shading** 모델이라고 하며 이를 사용해 명암을 표현한 결과는 아래와 같다.  Diffuse Shading 모델은 컴퓨터 그래픽에서 명암을 표현하는 가장 빠르고 기본적인 모델이며 통칭해서 **N dot L** 이라고도 한다. 

![](https://blogfiles.pstatic.net/MjAxODExMjhfMjY4/MDAxNTQzMzMyMDUwMDI0.Np04JCo8MXvLGjVqat_7l4O0XwaD0H1_6AKfdOtod_sg.GPlzp7Bbk--w9mcf1DsgYZHEPrvIjKq9BZm11UVNJ0Yg.PNG.destiny9720/Untitled-663611a1-c932-4f6e-a40b-4a9190808c28.png?type=w1)  


## 2. 벡터의 외적

- 벡터의 외적은 3차원 벡터에서만 사용 가능하다.
- 벡터의 외적은 두 벡터에 모두 수직인 벡터(== 법선 벡터)를 구하는 연산이다.  
    (서로 다른 요소만 조합하여 사용하는 특징이 있다.)

```null
a = (x1, y1, z1)
b = (x2, y2, z2)
a x b = [(y1·z2 - y2·z1), (z1·x2 - z2·x1), (x1·y2 - x2·y1)]
```

- 두 벡터의 사잇각을 θ라고 할 때 외적과 sin 함수의 관계는 다음과 같다.  
    (n은 두 벡터에 수직인 단위 벡터)

```null
a x b = |a|·|b|·sinθ·n
```

### 벡터의 외적 활용

**1) 두 벡터의 평행 판별**

- 외적을 했을 때 0이 나온다면 두 벡터는 평행한 벡터이다.

**2) 좌우 판별**

- 플레이어의 전방 벡터를 a, 플레이어에서 적을 향하는 벡터를 b, 게임 속 상향 벡터를 up이라고 할 때, up과 (a와 b의 외적)의 내적을 통해 적이 플레이어의 왼쪽에 있는지 오른쪽에 있는지 알 수 있다. (왼손 좌표계일 경우)
    - up·(a x b) > 0 : 적이 플레이어의 오른쪽에 있음.
    - up·(a x b) < 0 : 적이 플레이어의 왼쪽에 있음.